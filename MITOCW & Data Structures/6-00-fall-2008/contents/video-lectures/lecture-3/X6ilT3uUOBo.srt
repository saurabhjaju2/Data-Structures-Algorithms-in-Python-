1
00:00:00,000 --> 00:00:02,400
The following content is
provided under a Creative

2
00:00:02,400 --> 00:00:03,830
Commons license.

3
00:00:03,830 --> 00:00:06,250
Your support will help
MIT OpenCourseware

4
00:00:06,250 --> 00:00:10,510
continue to offer high-quality
educational resources for free.

5
00:00:10,510 --> 00:00:13,230
To make a donation, or
view additional materials

6
00:00:13,230 --> 00:00:16,600
from hundreds of MIT courses,
visit MIT OpenCourseware

7
00:00:16,600 --> 00:00:17,490
at ocw.mit.edu.

8
00:00:17,490 --> 00:00:22,080
PROFESSOR ERIC
GRIMSON: All right, I'm

9
00:00:22,080 --> 00:00:24,680
going to start today
by talking about,

10
00:00:24,680 --> 00:00:26,080
so what have we been doing?

11
00:00:26,080 --> 00:00:28,840
What have we actually done
over the last few lectures?

12
00:00:28,840 --> 00:00:30,590
And I want to suggest
that what we've done

13
00:00:30,590 --> 00:00:34,825
is, we've outlined a lot of the
basic elements of programming.

14
00:00:34,825 --> 00:00:36,200
A lot of the basic
elements we're

15
00:00:36,200 --> 00:00:37,890
going to need to write code.

16
00:00:37,890 --> 00:00:39,675
And I want to just highlight
it for you because we're going

17
00:00:39,675 --> 00:00:40,540
to come back and look at it.

18
00:00:40,540 --> 00:00:42,120
So I'm going to
suggest that we've

19
00:00:42,120 --> 00:00:45,530
looked at three different
kinds of things.

20
00:00:45,530 --> 00:00:51,480
We've talked about data,
we've talked about operations,

21
00:00:51,480 --> 00:00:59,310
and we've talked about
commands or statements.

22
00:00:59,310 --> 00:01:00,350
All right?

23
00:01:00,350 --> 00:01:01,860
Data's what we expect.

24
00:01:01,860 --> 00:01:04,570
It's our way of
representing fundamentally

25
00:01:04,570 --> 00:01:06,800
the kinds of information
we want to move around.

26
00:01:06,800 --> 00:01:11,010
And here, I'm going to
suggest we've seen numbers,

27
00:01:11,010 --> 00:01:14,740
we've seen strings,
and I'm going

28
00:01:14,740 --> 00:01:16,250
to add Booleans here as well.

29
00:01:16,250 --> 00:01:18,290
They're a third kind
of value that we

30
00:01:18,290 --> 00:01:21,840
saw when we started
talking about conditions.

31
00:01:21,840 --> 00:01:23,680
We saw, associated with
that primitive data,

32
00:01:23,680 --> 00:01:25,880
we have ways of taking
data in and creating

33
00:01:25,880 --> 00:01:28,400
new kinds of data out, or
new versions of data out,

34
00:01:28,400 --> 00:01:31,150
so we have operations.

35
00:01:31,150 --> 00:01:32,860
Things like addition
and multiplication,

36
00:01:32,860 --> 00:01:34,870
which we saw not only
apply to numbers,

37
00:01:34,870 --> 00:01:36,660
but we can use them
on things like strings

38
00:01:36,660 --> 00:01:38,630
and we're going to come
back to them again.

39
00:01:38,630 --> 00:01:41,296
Can't use them on Booleans, they
have a different set of things.

40
00:01:41,296 --> 00:01:45,162
They do things like AND, and OR.

41
00:01:45,162 --> 00:01:47,370
And of course there's a
bunch of other ones in there,

42
00:01:47,370 --> 00:01:48,320
I'm not going to
put them all up,

43
00:01:48,320 --> 00:01:50,611
but we're building up a little
collection, if you like,

44
00:01:50,611 --> 00:01:51,824
of those operations.

45
00:01:51,824 --> 00:01:53,240
And then the main
thing we've done

46
00:01:53,240 --> 00:01:54,750
is, we've talked about commands.

47
00:01:54,750 --> 00:01:57,640
So I'm going to suggest we've
seen now four different things.

48
00:01:57,640 --> 00:02:04,580
We've seen assignment, how
to bind a name to a value.

49
00:02:04,580 --> 00:02:10,660
We've seen input and output.

50
00:02:10,660 --> 00:02:15,090
Print for output, for example,
and raw input for input.

51
00:02:15,090 --> 00:02:23,430
We've seen conditionals, or
said another way, branches,

52
00:02:23,430 --> 00:02:26,170
ways of changing
the flow of control

53
00:02:26,170 --> 00:02:28,940
through that sequence of
instructions we're building up.

54
00:02:28,940 --> 00:02:31,540
And the last thing we
added were loop mechanisms.

55
00:02:31,540 --> 00:02:40,320
And here we saw, while.

56
00:02:40,320 --> 00:02:44,520
It's the first
example we've seen.

57
00:02:44,520 --> 00:02:46,520
So what've we done so far?

58
00:02:46,520 --> 00:02:50,257
Now, interestingly,
this set of instructions

59
00:02:50,257 --> 00:02:51,840
was actually quite
powerful, and we're

60
00:02:51,840 --> 00:02:53,715
going to come back to
that later on, in terms

61
00:02:53,715 --> 00:02:56,250
of what we can do with it,
but what we've really done

62
00:02:56,250 --> 00:02:58,510
is, given that basis,
we're now talking about,

63
00:02:58,510 --> 00:03:00,796
how do we write common
patterns of code,

64
00:03:00,796 --> 00:03:02,170
how do we write
things that solve

65
00:03:02,170 --> 00:03:03,795
particular kinds of problems.

66
00:03:03,795 --> 00:03:05,920
So what I want you to do,
is to keep in mind, those

67
00:03:05,920 --> 00:03:07,340
are the bases, we
ought to be able to do

68
00:03:07,340 --> 00:03:09,756
a lot with that bases, but
what we're really interested in

69
00:03:09,756 --> 00:03:12,320
is not filling out a whole
bunch of other things in here,

70
00:03:12,320 --> 00:03:14,570
but how do we put them
together into common templates.

71
00:03:14,570 --> 00:03:16,529
And we're going
to do that today.

72
00:03:16,529 --> 00:03:18,070
Second thing we've
been doing, I want

73
00:03:18,070 --> 00:03:21,169
to highlight for you is, we've
along the way, mostly just

74
00:03:21,169 --> 00:03:22,710
verbally rather than
writing it down,

75
00:03:22,710 --> 00:03:27,160
but we've been talking
about good style.

76
00:03:27,160 --> 00:03:28,431
Good programming style.

77
00:03:28,431 --> 00:03:28,930
All right?

78
00:03:28,930 --> 00:03:30,510
Things that we
ought to do, as you

79
00:03:30,510 --> 00:03:32,020
put these pieces
together, in order

80
00:03:32,020 --> 00:03:33,010
to give you really good code.

81
00:03:33,010 --> 00:03:34,892
And you should be
collecting those together.

82
00:03:34,892 --> 00:03:35,850
Give you some examples.

83
00:03:35,850 --> 00:03:36,933
What have we talked about?

84
00:03:36,933 --> 00:03:39,139
We've talked about things
like using comments

85
00:03:39,139 --> 00:03:40,930
to highlight what you're
doing in the code,

86
00:03:40,930 --> 00:03:42,890
to make it easier to debug.

87
00:03:42,890 --> 00:03:46,260
We talked about type
discipline, the notion

88
00:03:46,260 --> 00:03:49,669
that you should check
the types of operands

89
00:03:49,669 --> 00:03:52,210
before you apply operators to
them, to make sure that they're

90
00:03:52,210 --> 00:03:54,270
what the code is expecting.

91
00:03:54,270 --> 00:03:57,300
We talked about descriptive
use of good variable names,

92
00:03:57,300 --> 00:04:00,177
as a way, in essence, of
documenting your code.

93
00:04:00,177 --> 00:04:02,010
The fourth one we talked
about was this idea

94
00:04:02,010 --> 00:04:05,800
of testing all possible branches
through a piece of code,

95
00:04:05,800 --> 00:04:08,070
if it's got conditionals
in it, to make sure

96
00:04:08,070 --> 00:04:09,700
that every possible
input is going

97
00:04:09,700 --> 00:04:11,990
to give you an output that
you actually want to see.

98
00:04:11,990 --> 00:04:14,240
So, you know, you can start
writing your own, kind of,

99
00:04:14,240 --> 00:04:15,864
Miss Manners book,
if you like, I mean,

100
00:04:15,864 --> 00:04:17,350
are what are good
programming, you

101
00:04:17,350 --> 00:04:18,635
know-- I wonder what
you'd call them,

102
00:04:18,635 --> 00:04:20,100
John, good programming hygiene?

103
00:04:20,100 --> 00:04:21,300
Good programming style?

104
00:04:21,300 --> 00:04:23,520
Good programming
practices?-- Things that you

105
00:04:23,520 --> 00:04:26,190
want to do to write good code.

106
00:04:26,190 --> 00:04:26,807
OK.

107
00:04:26,807 --> 00:04:28,390
What we're going to
do today is, we're

108
00:04:28,390 --> 00:04:32,160
going to start now building
up, beyond just these pieces,

109
00:04:32,160 --> 00:04:35,840
although they're valuable, to
start creating two things: one,

110
00:04:35,840 --> 00:04:37,750
common patterns of
code that tackle

111
00:04:37,750 --> 00:04:40,680
certain classes of
problems, and secondly we're

112
00:04:40,680 --> 00:04:43,100
going to talk about tools you
can use to help understand

113
00:04:43,100 --> 00:04:45,040
those pieces of things.

114
00:04:45,040 --> 00:04:46,270
OK.

115
00:04:46,270 --> 00:04:49,340
So last time around, we talked
about, or introduced if you

116
00:04:49,340 --> 00:04:52,310
like, iterative programs.

117
00:04:52,310 --> 00:05:00,210
And I want to generalize
that for a second,

118
00:05:00,210 --> 00:05:08,090
because we're going to come
back and use this a lot.

119
00:05:08,090 --> 00:05:10,206
And I want to do a very
high-level description

120
00:05:10,206 --> 00:05:11,830
of what goes into an
iterative program,

121
00:05:11,830 --> 00:05:13,690
or how I would think
about this, all right?

122
00:05:13,690 --> 00:05:15,894
And I know if John disagrees
with me he'll tell me,

123
00:05:15,894 --> 00:05:17,560
but this is my way
of thinking about it.

124
00:05:17,560 --> 00:05:19,450
If I want to try and
decide how to tackle

125
00:05:19,450 --> 00:05:21,980
a problem in an iterative
matter, here the steps

126
00:05:21,980 --> 00:05:23,102
I'm going to go through.

127
00:05:23,102 --> 00:05:24,560
First thing I'm
going to do, is I'm

128
00:05:24,560 --> 00:05:35,825
going to choose a variable
that's going to count.

129
00:05:35,825 --> 00:05:37,950
What I meant-- what in the
world do I mean by that?

130
00:05:37,950 --> 00:05:39,150
I'm thinking about
a problem, I'm

131
00:05:39,150 --> 00:05:41,190
going to show you an example
in a second, first thing I'm

132
00:05:41,190 --> 00:05:43,023
going to do is say,
what is the thing that's

133
00:05:43,023 --> 00:05:46,190
going to change every time I run
through the same set of code?

134
00:05:46,190 --> 00:05:48,880
What is counting my way
through this process?

135
00:05:48,880 --> 00:05:51,400
Now I'm putting count
in double quotes,

136
00:05:51,400 --> 00:05:54,232
not to make it a string, but to
say, this is count generically.

137
00:05:54,232 --> 00:05:56,440
It could be counting one by
one through the integers,

138
00:05:56,440 --> 00:05:58,940
it could also be taking
a collection of data

139
00:05:58,940 --> 00:06:00,640
and going through
them one by one.

140
00:06:00,640 --> 00:06:02,765
It could be doing counting
in some other mechanism.

141
00:06:02,765 --> 00:06:05,080
But what's the
variable I want to use?

142
00:06:05,080 --> 00:06:11,210
Second thing I do, I
need to initialize it.

143
00:06:11,210 --> 00:06:16,510
And I need to initialize
it outside of the loop.

144
00:06:16,510 --> 00:06:18,260
That is, where do
I want to start?

145
00:06:18,260 --> 00:06:21,330
And I need to make sure I have
a command that sets that up.

146
00:06:21,330 --> 00:06:23,350
The third thing
I'm going to do, is

147
00:06:23,350 --> 00:06:28,280
I need to set up
the right end test.

148
00:06:28,280 --> 00:06:31,691
How do I know when I'm
done with the loop?

149
00:06:31,691 --> 00:06:33,190
And obviously, that
ought to involve

150
00:06:33,190 --> 00:06:34,731
the variable in some
way, or it's not

151
00:06:34,731 --> 00:06:37,910
going to make a lot of sense,
so this includes the variable,

152
00:06:37,910 --> 00:06:40,640
since that's the
thing that's changing.

153
00:06:40,640 --> 00:06:41,140
All right.

154
00:06:41,140 --> 00:06:43,140
The fourth thing
I'm going to do,

155
00:06:43,140 --> 00:06:51,177
is I'm going to then
construct the block of code.

156
00:06:51,177 --> 00:06:53,010
And I want to remind
you, that block of code

157
00:06:53,010 --> 00:06:55,980
is a set of instructions,
the same set of instructions

158
00:06:55,980 --> 00:06:58,200
that are going to be done
each time through the loop.

159
00:06:58,200 --> 00:07:00,408
All that's going to change,
is the value the variable

160
00:07:00,408 --> 00:07:02,280
or the value of some
data structures.

161
00:07:02,280 --> 00:07:05,570
And remind you that
inside of here,

162
00:07:05,570 --> 00:07:10,677
I'd better be
changing the variable.

163
00:07:10,677 --> 00:07:12,760
All right, if that variable
that's counting is not

164
00:07:12,760 --> 00:07:14,926
changing, I'm going to be
stuck in an infinite loop,

165
00:07:14,926 --> 00:07:16,860
so I ought to
[UNINTELLIGIBLE PHRASE] that ,

166
00:07:16,860 --> 00:07:18,720
right, expect
somewhere in there,

167
00:07:18,720 --> 00:07:20,570
a change of that variable.

168
00:07:20,570 --> 00:07:21,070
All right?

169
00:07:21,070 --> 00:07:22,611
And then the last
thing I want to do,

170
00:07:22,611 --> 00:07:32,611
is just decide, you know,
what do I do when I'm done.

171
00:07:32,611 --> 00:07:33,110
OK.

172
00:07:33,110 --> 00:07:33,680
I know.

173
00:07:33,680 --> 00:07:35,310
It looks boring.

174
00:07:35,310 --> 00:07:36,790
But it's a structure
of the things

175
00:07:36,790 --> 00:07:38,710
I want to think about
when I go through trying

176
00:07:38,710 --> 00:07:41,420
to take a problem and mapping
it into a iterative program.

177
00:07:41,420 --> 00:07:43,461
Those are the things I
want to see if I go along.

178
00:07:43,461 --> 00:07:44,380
All right.

179
00:07:44,380 --> 00:07:47,880
So let me give you an example.

180
00:07:47,880 --> 00:07:50,739
I'm given an integer
that's a perfect square,

181
00:07:50,739 --> 00:07:53,030
and I want to write a little
piece of code that's going

182
00:07:53,030 --> 00:07:54,730
to find the square root of it.

183
00:07:54,730 --> 00:07:55,560
All right, so I'm
cheating a little,

184
00:07:55,560 --> 00:07:56,890
I know it's a perfect
square, somebody's

185
00:07:56,890 --> 00:07:59,514
given it to me, we'll come back
in a second to generalizing it,

186
00:07:59,514 --> 00:08:02,480
so what would the steps be that
I'd use to walk through it?

187
00:08:02,480 --> 00:08:04,650
Well if you think
about these steps,

188
00:08:04,650 --> 00:08:06,540
here's an easy way to do it.

189
00:08:06,540 --> 00:08:07,530
Let's start at 1.

190
00:08:07,530 --> 00:08:08,570
Let's call x the
thing I'm trying

191
00:08:08,570 --> 00:08:09,694
to find the square root of.

192
00:08:09,694 --> 00:08:10,780
Let's start at 1.

193
00:08:10,780 --> 00:08:12,740
Square it.

194
00:08:12,740 --> 00:08:16,620
If it's not greater
than x, take 2.

195
00:08:16,620 --> 00:08:17,682
Square it.

196
00:08:17,682 --> 00:08:19,140
If it's not greater
than x, take 3.

197
00:08:19,140 --> 00:08:19,640
Square it.

198
00:08:19,640 --> 00:08:22,580
And keep going, until the
square of one of those integers

199
00:08:22,580 --> 00:08:27,390
is greater than or equal to--
sorry, just greater than x.

200
00:08:27,390 --> 00:08:28,590
OK, why am I doing that?

201
00:08:28,590 --> 00:08:31,210
When I get greater than x,
I've gone past the place

202
00:08:31,210 --> 00:08:32,527
where I want to be.

203
00:08:32,527 --> 00:08:34,110
And obviously, when
I get to something

204
00:08:34,110 --> 00:08:36,900
whose square is equal to x,
I've got the answer I want,

205
00:08:36,900 --> 00:08:37,944
and I kick it out.

206
00:08:37,944 --> 00:08:39,110
So who knows what I've done?

207
00:08:39,110 --> 00:08:41,276
I've identified the thing
I'm going to use to count,

208
00:08:41,276 --> 00:08:43,870
something some variable is going
to just count the integers,

209
00:08:43,870 --> 00:08:45,570
I've identified
the end test, which

210
00:08:45,570 --> 00:08:48,370
is when that square is bigger
than the thing I'm looking

211
00:08:48,370 --> 00:08:51,260
for, I've identified
basically what I want

212
00:08:51,260 --> 00:08:53,930
to do inside the
loop, which is simply

213
00:08:53,930 --> 00:08:55,669
keep changing that
variable, and I

214
00:08:55,669 --> 00:08:57,460
didn't say what I want
to do when I'm done,

215
00:08:57,460 --> 00:09:00,220
essentially print
out the answer.

216
00:09:00,220 --> 00:09:01,580
OK, so how can I code this up?

217
00:09:01,580 --> 00:09:02,900
Well, you might think,
let's just jump in

218
00:09:02,900 --> 00:09:04,600
and write some code, I don't
want to quite do that though,

219
00:09:04,600 --> 00:09:06,516
because I want to show
you another tool that's

220
00:09:06,516 --> 00:09:10,100
valuable for thinking about
how to structure the code,

221
00:09:10,100 --> 00:09:15,680
and that is a something
called a flow chart.

222
00:09:15,680 --> 00:09:17,790
Now.

223
00:09:17,790 --> 00:09:19,640
People of Professor
Guttag's and my age,

224
00:09:19,640 --> 00:09:22,060
unfortunately remember flow
charts back-- as they say,

225
00:09:22,060 --> 00:09:24,962
on the Simpsons, back in the
day, back in the 1960's, John,

226
00:09:24,962 --> 00:09:27,420
right?-- really good programmers
had these wonderful little

227
00:09:27,420 --> 00:09:29,120
plastic stencils, I
tried to find one,

228
00:09:29,120 --> 00:09:31,680
I couldn't find it It's a little
stencil with little cut-out

229
00:09:31,680 --> 00:09:33,680
shapes on it, that you
used to draw flow charts,

230
00:09:33,680 --> 00:09:34,780
I'm going to show
you in a second,

231
00:09:34,780 --> 00:09:37,010
and you tucked it right in here
next to your pocket protector

232
00:09:37,010 --> 00:09:38,468
with all your pens
in it, you know,

233
00:09:38,468 --> 00:09:40,130
so, your belt was
also about this high,

234
00:09:40,130 --> 00:09:41,921
and your glasses were
this thick, you know,

235
00:09:41,921 --> 00:09:43,804
we have a few of
those nerds left,

236
00:09:43,804 --> 00:09:45,220
we mostly keep
them in the museum,

237
00:09:45,220 --> 00:09:48,120
but that was what you
did with the flow chart.

238
00:09:48,120 --> 00:09:49,720
Despite making a
bad joke about it,

239
00:09:49,720 --> 00:09:50,780
we're going to do
the same thing here.

240
00:09:50,780 --> 00:09:50,965
We're going to do
the same thing here,

241
00:09:50,965 --> 00:09:53,330
we're going to chart
out a little bit of what

242
00:09:53,330 --> 00:09:56,780
should go into actually
making this thing work.

243
00:09:56,780 --> 00:09:58,456
So here's a simple
flow chart that I'm

244
00:09:58,456 --> 00:10:01,059
going to use to capture
what I just described.

245
00:10:01,059 --> 00:10:02,600
And I'm going to,
again, I'm actually

246
00:10:02,600 --> 00:10:06,090
going to do it the way they
used to do it, and draw

247
00:10:06,090 --> 00:10:09,730
a rectangle with
rounded corners, that's

248
00:10:09,730 --> 00:10:12,540
my starting point, and
then what did I say to do?

249
00:10:12,540 --> 00:10:14,350
I said I need to
identify a variable,

250
00:10:14,350 --> 00:10:16,391
I'm going to give it a
name, let's just call ANS,

251
00:10:16,391 --> 00:10:19,250
for answer, and I
need to initialize it,

252
00:10:19,250 --> 00:10:22,170
so I'm going to come
down, and in a square box,

253
00:10:22,170 --> 00:10:29,815
I'm going to
initialize ANS to 0.

254
00:10:29,815 --> 00:10:31,440
And now I want to
run through the loop.

255
00:10:31,440 --> 00:10:33,023
What's the first
thing I do in a loop?

256
00:10:33,023 --> 00:10:34,110
I test an end test.

257
00:10:34,110 --> 00:10:36,830
So the flow chart says,
and the tradition was

258
00:10:36,830 --> 00:10:40,190
to do this in a
diamond shape, I'm

259
00:10:40,190 --> 00:10:44,770
going to check if
ANS times ANS-- oh,

260
00:10:44,770 --> 00:10:47,390
which way did I want to
do this-- is less than

261
00:10:47,390 --> 00:10:51,840
or equal to x.

262
00:10:51,840 --> 00:10:52,780
Now that's a test.

263
00:10:52,780 --> 00:10:54,570
There are two possibilities.

264
00:10:54,570 --> 00:11:00,535
If the answer is yes, then I'm
still looking for the answer,

265
00:11:00,535 --> 00:11:01,410
what do I want to do?

266
00:11:01,410 --> 00:11:03,034
Well, I don't have
to do anything other

267
00:11:03,034 --> 00:11:04,270
than change the counter.

268
00:11:04,270 --> 00:11:09,770
So I'm going to go
to ANS is ANS plus 1,

269
00:11:09,770 --> 00:11:17,240
and I'm going to do it again.

270
00:11:17,240 --> 00:11:22,559
Eventually, if I've done
this right, that test is no--

271
00:11:22,559 --> 00:11:24,850
and I wonderfully ran out of
room here-- in which case,

272
00:11:24,850 --> 00:11:27,100
I'm going to go to a print
statement, which was always

273
00:11:27,100 --> 00:11:32,930
done in a trapezoid,
and print out ANS.

274
00:11:32,930 --> 00:11:36,550
I should have put a box
below it that says stop.

275
00:11:36,550 --> 00:11:38,420
OK?

276
00:11:38,420 --> 00:11:39,735
While.

277
00:11:39,735 --> 00:11:40,860
And notice what I got here.

278
00:11:40,860 --> 00:11:43,010
Actually, this is a useful
tool for visualizing

279
00:11:43,010 --> 00:11:44,590
how I'm trying to
put it together,

280
00:11:44,590 --> 00:11:47,640
because it lets me
see where the loop is,

281
00:11:47,640 --> 00:11:50,530
right there, it lets
me see the end test,

282
00:11:50,530 --> 00:11:53,200
it lets me make sure that I'm in
fact initializing the variable

283
00:11:53,200 --> 00:11:55,722
and I'm checking the right
things as I go along.

284
00:11:55,722 --> 00:11:58,180
And the idea of this flow chart
is, if you start, you know,

285
00:11:58,180 --> 00:12:01,632
a little ball bearing here, it's
going to roll down, setting up

286
00:12:01,632 --> 00:12:03,840
an assignment statement,
and then, depending on here,

287
00:12:03,840 --> 00:12:05,130
it's like there's a pair
of flippers in there,

288
00:12:05,130 --> 00:12:06,921
it does the test, it
sets the ball this way

289
00:12:06,921 --> 00:12:09,415
to change it to ANS plus
1, and comes back around,

290
00:12:09,415 --> 00:12:11,540
eventually it's going to
drop through and print out

291
00:12:11,540 --> 00:12:12,040
the answer.

292
00:12:12,040 --> 00:12:14,514
The reason I'm going to
show you this flow chart,

293
00:12:14,514 --> 00:12:16,430
I'm going to do one other
example in a second,

294
00:12:16,430 --> 00:12:17,710
but I want to show
you a comparison.

295
00:12:17,710 --> 00:12:19,959
Remember last time, we wrote
this simple piece of code

296
00:12:19,959 --> 00:12:21,690
to print out even or odd.

297
00:12:21,690 --> 00:12:25,321
If, you know, x, it was
in fact, even or odd.

298
00:12:25,321 --> 00:12:26,820
So let me show you
what a flow chart

299
00:12:26,820 --> 00:12:28,820
for that would look like,
because I want to make

300
00:12:28,820 --> 00:12:35,140
a comparison point here.

301
00:12:35,140 --> 00:12:40,050
If I were to do a flow chart for
that one, I'd do the following.

302
00:12:40,050 --> 00:12:48,527
It reminds you,
that the test here

303
00:12:48,527 --> 00:12:50,610
was, we took x if that's
what we were looking for,

304
00:12:50,610 --> 00:12:54,360
it did integer division
by 2, multiplied it by 2,

305
00:12:54,360 --> 00:12:58,740
and we check to see if
that was the same as x.

306
00:12:58,740 --> 00:13:10,580
If the answer is yes, then
we did a print of even.

307
00:13:10,580 --> 00:13:21,240
If the answer was no,
we did a print of odd,

308
00:13:21,240 --> 00:13:27,000
and we then carried on.

309
00:13:27,000 --> 00:13:28,160
Again, while.

310
00:13:28,160 --> 00:13:30,515
But there's an
important point here.

311
00:13:30,515 --> 00:13:32,140
Remember last time,
I said that there's

312
00:13:32,140 --> 00:13:35,660
different kinds of
complexity in our code,

313
00:13:35,660 --> 00:13:39,720
and I suggested for simple
branching programs, the amount

314
00:13:39,720 --> 00:13:41,650
of time it takes
to run that program

315
00:13:41,650 --> 00:13:44,370
is, in essence, bounded by
the number of instructions,

316
00:13:44,370 --> 00:13:47,540
because you only execute each
instruction at most once.

317
00:13:47,540 --> 00:13:49,970
It didn't depend on
the size of the input.

318
00:13:49,970 --> 00:13:52,660
And you can see that there.

319
00:13:52,660 --> 00:13:57,060
I start off, either I take
this path and carry on,

320
00:13:57,060 --> 00:14:01,340
or I take that path and carry
on, but each box, if you like,

321
00:14:01,340 --> 00:14:02,580
gets touched exactly once.

322
00:14:02,580 --> 00:14:06,370
On the other hand,
look at this one.

323
00:14:06,370 --> 00:14:10,290
This depends now
on the size of x.

324
00:14:10,290 --> 00:14:11,801
All right?

325
00:14:11,801 --> 00:14:13,050
Because what am I going to do?

326
00:14:13,050 --> 00:14:15,383
I'm going to come down and
say, is ANS squared less than

327
00:14:15,383 --> 00:14:15,970
or equal to x?

328
00:14:15,970 --> 00:14:18,190
If it is, I'm going to
go around, and execute

329
00:14:18,190 --> 00:14:21,300
that statement, check it again,
and go around and execute that.

330
00:14:21,300 --> 00:14:24,400
So I'm going to cycle
around that loop there

331
00:14:24,400 --> 00:14:26,120
enough times to
get to the answer,

332
00:14:26,120 --> 00:14:28,500
and that number of times is
going to depend on the input,

333
00:14:28,500 --> 00:14:30,920
so as I change the
input, I'm going

334
00:14:30,920 --> 00:14:33,380
to change the
complexity of the code.

335
00:14:33,380 --> 00:14:37,060
Now this happens to be what we
would call a linear process,

336
00:14:37,060 --> 00:14:39,260
because the number of
times I go around the loop

337
00:14:39,260 --> 00:14:41,467
is directly related to
the size of the argument.

338
00:14:41,467 --> 00:14:42,925
If I double the
argument, I'm going

339
00:14:42,925 --> 00:14:45,273
to double the number of
times I go around the loop.

340
00:14:45,273 --> 00:14:46,731
If I increase it
by five, I'm going

341
00:14:46,731 --> 00:14:49,330
to increase by five the number
of times I go around the loop.

342
00:14:49,330 --> 00:14:51,650
We'll see later on, there
are classes of computation

343
00:14:51,650 --> 00:14:54,059
that are inherently
much more complex.

344
00:14:54,059 --> 00:14:55,600
We hate them, because
they're costly,

345
00:14:55,600 --> 00:14:57,830
but they're sometimes
inherently that way.

346
00:14:57,830 --> 00:15:01,150
But you can see the
comparison between these two.

347
00:15:01,150 --> 00:15:01,850
OK.

348
00:15:01,850 --> 00:15:07,400
Now, having done that,
let's build this code.

349
00:15:07,400 --> 00:15:11,660
Yeah, if my machine will
come back up, there we go.

350
00:15:11,660 --> 00:15:14,285
So, I'm going to now
go ahead and write

351
00:15:14,285 --> 00:15:16,100
a little piece of
code, and I put it here

352
00:15:16,100 --> 00:15:20,190
and I hope you can actually
see these better this time,

353
00:15:20,190 --> 00:15:23,140
let me uncomment that region.

354
00:15:23,140 --> 00:15:25,600
All right.

355
00:15:25,600 --> 00:15:28,080
So, there's basically an
encapsulation of that code,

356
00:15:28,080 --> 00:15:29,060
right?

357
00:15:29,060 --> 00:15:32,819
It says-- what, look
at this, where am I,

358
00:15:32,819 --> 00:15:34,860
right here-- I've got some
value for x initially,

359
00:15:34,860 --> 00:15:37,850
I'm going to set ANS
to 0, just like there,

360
00:15:37,850 --> 00:15:41,770
and there's my loop, there's the
test, which is right like that,

361
00:15:41,770 --> 00:15:43,820
is ANS squared less
than or equal to x,

362
00:15:43,820 --> 00:15:48,140
if it is, there's the block
corresponding to the loop,

363
00:15:48,140 --> 00:15:50,810
change ANS, and eventually when
I'm done with all this thing,

364
00:15:50,810 --> 00:15:53,090
I'm just going to print ANS out.

365
00:15:53,090 --> 00:15:53,590
OK.

366
00:15:53,590 --> 00:15:57,430
All right, let me show you one
other tool that I want to use.

367
00:15:57,430 --> 00:16:00,000
Which is, I've written
that piece of code,

368
00:16:00,000 --> 00:16:01,030
I ought to check it.

369
00:16:01,030 --> 00:16:04,150
Well, I could just run it,
but another useful thing to do

370
00:16:04,150 --> 00:16:07,020
is, I'm, especially as I
want to debug these things,

371
00:16:07,020 --> 00:16:08,310
is to simulate that code.

372
00:16:08,310 --> 00:16:12,890
And I'm going to do this
because, as Professor

373
00:16:12,890 --> 00:16:15,320
Guttag noticed to me, students
seem reluctant to do this.

374
00:16:15,320 --> 00:16:16,950
I guess it's not
macho enough, John,

375
00:16:16,950 --> 00:16:19,894
to just, you know, you know,
go off and do things by hand,

376
00:16:19,894 --> 00:16:22,060
you ought to just run them,
but it's a valuable tool

377
00:16:22,060 --> 00:16:23,560
to get into, so let
me do that here.

378
00:16:23,560 --> 00:16:25,905
STUDENT: [UNINTELLIGIBLE]

379
00:16:25,905 --> 00:16:28,030
PROFESSOR ERIC GRIMSON:
I'm doing such a great job.

380
00:16:28,030 --> 00:16:30,590
I've got to say, when my, I've
got two sons, now aged eighteen

381
00:16:30,590 --> 00:16:31,880
and twenty, they
used to think I had

382
00:16:31,880 --> 00:16:33,463
the coolest job in
the world because I

383
00:16:33,463 --> 00:16:34,820
came home covered in chalk.

384
00:16:34,820 --> 00:16:37,111
Now they have a different
opinion that you can probably

385
00:16:37,111 --> 00:16:39,450
figure out.

386
00:16:39,450 --> 00:16:40,060
All right.

387
00:16:40,060 --> 00:16:41,650
Simulate the code.

388
00:16:41,650 --> 00:16:43,920
What I mean by that is,
pick a simple set of values,

389
00:16:43,920 --> 00:16:46,014
and let's walk through
it to see what happens.

390
00:16:46,014 --> 00:16:47,555
And this is useful
because it's going

391
00:16:47,555 --> 00:16:50,379
to allow me to A, make sure
that I've got something that's

392
00:16:50,379 --> 00:16:51,920
going to terminate,
it's going to let

393
00:16:51,920 --> 00:16:53,430
me make sure that
in fact I'm doing

394
00:16:53,430 --> 00:16:54,830
the right kinds of updates.

395
00:16:54,830 --> 00:16:57,000
I could do this, by the
way, by running the code

396
00:16:57,000 --> 00:16:59,350
and putting print statements
in various places as well,

397
00:16:59,350 --> 00:17:00,870
but the hand
simulation is valuable,

398
00:17:00,870 --> 00:17:02,280
so let me just start it.

399
00:17:02,280 --> 00:17:03,300
What do I have here?

400
00:17:03,300 --> 00:17:10,030
I need the variable,
ANS, I need x,

401
00:17:10,030 --> 00:17:11,780
and I need ANS times
ANS, ANS times ANS.

402
00:17:11,780 --> 00:17:12,280
Right.

403
00:17:12,280 --> 00:17:13,738
Those are the three
things that are

404
00:17:13,738 --> 00:17:15,760
involved in this
computation. and I pick

405
00:17:15,760 --> 00:17:17,050
something reasonably simple.

406
00:17:17,050 --> 00:17:19,780
The ANS starts at 0.

407
00:17:19,780 --> 00:17:22,417
I set up x, I think,
to be 16 there.

408
00:17:22,417 --> 00:17:23,500
So what does the loop say?

409
00:17:23,500 --> 00:17:24,740
I can either look
at my flow chart,

410
00:17:24,740 --> 00:17:25,520
or I can look at the code.

411
00:17:25,520 --> 00:17:28,060
If I look at the flow chart,
it says, I'm at this point.

412
00:17:28,060 --> 00:17:29,071
Look at ANS squared.

413
00:17:29,071 --> 00:17:30,570
Is it less than or
equal to-- sorry,

414
00:17:30,570 --> 00:17:33,300
first of all, ANS squared is 0,
is it less than or equal to x,

415
00:17:33,300 --> 00:17:34,170
yes.

416
00:17:34,170 --> 00:17:35,610
So what do I do?

417
00:17:35,610 --> 00:17:36,360
Change ANS.

418
00:17:36,360 --> 00:17:39,810
X doesn't change.

419
00:17:39,810 --> 00:17:41,660
Back around to the test.

420
00:17:41,660 --> 00:17:42,840
What's ANS squared?

421
00:17:42,840 --> 00:17:43,870
It's 1.

422
00:17:43,870 --> 00:17:45,260
Is it less than or equal to 16?

423
00:17:45,260 --> 00:17:46,250
Sure.

424
00:17:46,250 --> 00:17:47,210
Run the loop again.

425
00:17:47,210 --> 00:17:49,640
ANS becomes 2.

426
00:17:49,640 --> 00:17:50,950
X stays 16.

427
00:17:50,950 --> 00:17:53,200
ANS squared is 4.

428
00:17:53,200 --> 00:17:55,250
Is that less than
or equal to 16?

429
00:17:55,250 --> 00:17:55,750
Yes.

430
00:17:55,750 --> 00:17:58,650
Aren't you glad I didn't
pick x equals 500?

431
00:17:58,650 --> 00:18:00,430
All right.

432
00:18:00,430 --> 00:18:02,040
ANS goes up by 0.

433
00:18:02,040 --> 00:18:03,970
ANS squared is nine.

434
00:18:03,970 --> 00:18:06,390
Still less than or equal to 16.

435
00:18:06,390 --> 00:18:07,370
ANS goes to 4.

436
00:18:07,370 --> 00:18:10,490
X stays the same.

437
00:18:10,490 --> 00:18:12,500
4 squared is 16.

438
00:18:12,500 --> 00:18:14,540
Is 16 less than or equal to 16?

439
00:18:14,540 --> 00:18:15,490
Yes.

440
00:18:15,490 --> 00:18:17,380
So ANS goes to five.

441
00:18:17,380 --> 00:18:19,030
ANS squared becomes 25.

442
00:18:19,030 --> 00:18:19,920
Ah!

443
00:18:19,920 --> 00:18:25,340
That is now no longer true
here, so I print out 5.

444
00:18:25,340 --> 00:18:27,110
Right.

445
00:18:27,110 --> 00:18:27,610
Sure.

446
00:18:27,610 --> 00:18:28,780
Square root of 16 is 5.

447
00:18:28,780 --> 00:18:31,050
It's Bush economics.

448
00:18:31,050 --> 00:18:33,350
OK?

449
00:18:33,350 --> 00:18:33,920
I know.

450
00:18:33,920 --> 00:18:37,070
I'm not supposed to make
bad jokes like that.

451
00:18:37,070 --> 00:18:38,740
What happened?

452
00:18:38,740 --> 00:18:39,240
Yeah.

453
00:18:39,240 --> 00:18:47,904
STUDENT: It doesn't
stop at the right place.

454
00:18:47,904 --> 00:18:49,320
PROFESSOR ERIC
GRIMSON: It doesn't

455
00:18:49,320 --> 00:18:49,650
stop at the right place.

456
00:18:49,650 --> 00:18:49,971
Thank you.

457
00:18:49,971 --> 00:18:50,080
Exactly.

458
00:18:50,080 --> 00:18:50,620
Right?

459
00:18:50,620 --> 00:18:53,680
My bug here is right there.

460
00:18:53,680 --> 00:18:58,070
Ah, let me find my cursor.

461
00:18:58,070 --> 00:18:59,920
I probably want that.

462
00:18:59,920 --> 00:19:00,420
Right?

463
00:19:00,420 --> 00:19:02,820
I want less than, rather
than less than or equal to.

464
00:19:02,820 --> 00:19:05,360
This is an easy bug
to come up with.

465
00:19:05,360 --> 00:19:07,140
But imagine, if you
don't do the test,

466
00:19:07,140 --> 00:19:09,389
you're going to get answers
that don't make any sense.

467
00:19:09,389 --> 00:19:11,820
And in fact, if we just
go ahead and run this now,

468
00:19:11,820 --> 00:19:17,532
hopefully we get
out-- oops, sorry,

469
00:19:17,532 --> 00:19:19,240
I'm going to have to
change this quickly,

470
00:19:19,240 --> 00:19:20,900
I still have some
things uncommented

471
00:19:20,900 --> 00:19:23,010
at the bottom, yeah,
there they are,

472
00:19:23,010 --> 00:19:25,460
I don't think we
need that yet, all

473
00:19:25,460 --> 00:19:32,660
right, we will
comment those out.

474
00:19:32,660 --> 00:19:35,460
OK.

475
00:19:35,460 --> 00:19:38,250
So.

476
00:19:38,250 --> 00:19:39,060
Why did I do it?

477
00:19:39,060 --> 00:19:41,970
It's a simple example, I agree,
but notice what I just did.

478
00:19:41,970 --> 00:19:44,780
It allowed me to highlight, is
the code doing the right thing?

479
00:19:44,780 --> 00:19:47,317
I spotted an error here,
I could have spotted it

480
00:19:47,317 --> 00:19:49,900
by running it on different test
sets, and using prints things,

481
00:19:49,900 --> 00:19:51,483
another way of doing
it, but this idea

482
00:19:51,483 --> 00:19:53,530
of at least simulating
it on simple examples

483
00:19:53,530 --> 00:19:56,402
lets you check a couple
of important questions.

484
00:19:56,402 --> 00:19:58,360
And in fact, now let me
ask those two questions

485
00:19:58,360 --> 00:20:00,240
about this piece of code.

486
00:20:00,240 --> 00:20:03,630
First question is, for
what values of integers--

487
00:20:03,630 --> 00:20:06,810
we're going to assume integers--
but for what values of x

488
00:20:06,810 --> 00:20:09,470
does this code terminate?

489
00:20:09,470 --> 00:20:12,670
And the second question
is, for what values of x

490
00:20:12,670 --> 00:20:14,690
does it give me back
the right answer?

491
00:20:14,690 --> 00:20:18,370
All right, first question.

492
00:20:18,370 --> 00:20:22,270
What values of x
does it terminate?

493
00:20:22,270 --> 00:20:26,230
Again, assume x is an integer.

494
00:20:26,230 --> 00:20:27,840
Well, break it down into pieces.

495
00:20:27,840 --> 00:20:29,770
Suppose x is positive.

496
00:20:29,770 --> 00:20:32,380
Does it terminate?

497
00:20:32,380 --> 00:20:33,031
Sure.

498
00:20:33,031 --> 00:20:33,530
All right?

499
00:20:33,530 --> 00:20:37,760
Because ANS starts out
as 0, so ANS squared is

500
00:20:37,760 --> 00:20:41,580
0, and each time through
the loop, ANS is increasing.

501
00:20:41,580 --> 00:20:44,410
That means, at some point, in
some finite number of steps,

502
00:20:44,410 --> 00:20:47,860
ANS squared has got to get
bigger than x if x is positive.

503
00:20:47,860 --> 00:20:50,360
So for positive
integers, it terminates.

504
00:20:50,360 --> 00:20:52,510
And it probably, I
think we can deduce,

505
00:20:52,510 --> 00:20:54,281
returns the right answer here.

506
00:20:54,281 --> 00:20:54,780
Right.

507
00:20:54,780 --> 00:20:56,530
X is negative.

508
00:20:56,530 --> 00:20:59,570
X is -16.

509
00:20:59,570 --> 00:21:05,080
Does this code terminate?

510
00:21:05,080 --> 00:21:08,940
Boy, I feel like
Arnold Schwarzenegger.

511
00:21:08,940 --> 00:21:11,050
Does this terminate?

512
00:21:11,050 --> 00:21:11,550
Somebody.

513
00:21:11,550 --> 00:21:13,947
STUDENT: [UNINTELLIGIBLE]

514
00:21:13,947 --> 00:21:15,530
PROFESSOR ERIC
GRIMSON: Ah, thank you,

515
00:21:15,530 --> 00:21:16,740
so it does terminate, right?

516
00:21:16,740 --> 00:21:21,090
You're sitting too far back, let
me try-- oh, too far!-- Sorry.

517
00:21:21,090 --> 00:21:23,200
Come get me one later
if you can't find it.

518
00:21:23,200 --> 00:21:25,790
Yes, it stops at the
first step, right?

519
00:21:25,790 --> 00:21:26,700
Let's look at it.

520
00:21:26,700 --> 00:21:30,910
It says, if answer, sorry,
imagine x is -16, ANS is 0,

521
00:21:30,910 --> 00:21:35,950
is 0 less than -16, no.

522
00:21:35,950 --> 00:21:37,450
So what does it do?

523
00:21:37,450 --> 00:21:39,860
It prints out 0.

524
00:21:39,860 --> 00:21:40,400
Ah!

525
00:21:40,400 --> 00:21:43,980
So that now answers my second
question, it does terminate,

526
00:21:43,980 --> 00:21:46,630
but does it give me
the right answer?

527
00:21:46,630 --> 00:21:47,280
No.

528
00:21:47,280 --> 00:21:47,590
Right?

529
00:21:47,590 --> 00:21:49,006
It gives me an
answer, and imagine

530
00:21:49,006 --> 00:21:51,970
I'm using this somewhere else,
you know, it's going to go off

531
00:21:51,970 --> 00:21:54,502
and say, gee, the
square root of -16 is 0.

532
00:21:54,502 --> 00:21:56,960
Well, it really should be a,
you know, an imaginary number,

533
00:21:56,960 --> 00:21:59,220
but this is not a valuable
thing to have come back.

534
00:21:59,220 --> 00:22:01,470
So that's the second thing
I've just highlighted here,

535
00:22:01,470 --> 00:22:05,255
is that I now have the
ability to check whether it

536
00:22:05,255 --> 00:22:06,130
does the right thing.

537
00:22:06,130 --> 00:22:08,297
And those are two
things that you'd

538
00:22:08,297 --> 00:22:10,380
like to do with every
looping construct you write:

539
00:22:10,380 --> 00:22:13,320
you'd like to be able to assure
yourself that they will always

540
00:22:13,320 --> 00:22:16,040
terminate, and then the
second thing you'd like to do,

541
00:22:16,040 --> 00:22:18,040
is to assure yourself
that it does give you back

542
00:22:18,040 --> 00:22:19,860
a reasonable answer.

543
00:22:19,860 --> 00:22:21,970
We started to talk about
ways to do the former.

544
00:22:21,970 --> 00:22:22,920
It's looking at the end test.

545
00:22:22,920 --> 00:22:24,300
It's looking at the
kinds of conditions

546
00:22:24,300 --> 00:22:25,430
you're going to put in.

547
00:22:25,430 --> 00:22:27,520
For the latter, this
is a place where

548
00:22:27,520 --> 00:22:31,170
running test cases would do a
good job of helping with that.

549
00:22:31,170 --> 00:22:34,550
Nonetheless, having done that,
let's look at a better way

550
00:22:34,550 --> 00:22:35,850
to write this.

551
00:22:35,850 --> 00:22:40,980
Which is right here, it is
also, I think, on your sheet,

552
00:22:40,980 --> 00:22:47,650
I'm going to uncomment that,
and comment this one out, yeah.

553
00:22:47,650 --> 00:22:50,500
All right?

554
00:22:50,500 --> 00:22:53,360
So let's look at this
code for a second.

555
00:22:53,360 --> 00:22:54,420
Notice what this does.

556
00:22:54,420 --> 00:22:57,100
Certainly the heart
of it, right in here,

557
00:22:57,100 --> 00:22:59,800
is still the same thing.

558
00:22:59,800 --> 00:23:00,930
But notice what this does.

559
00:23:00,930 --> 00:23:02,930
The first thing it does
is, it says, let's check

560
00:23:02,930 --> 00:23:05,470
and make sure x is greater
than or equal to 0.

561
00:23:05,470 --> 00:23:07,770
If it isn't, notice
what's going to happen.

562
00:23:07,770 --> 00:23:09,984
None of that block is
going to get executed,

563
00:23:09,984 --> 00:23:11,900
and it's going to come
down here and print out

564
00:23:11,900 --> 00:23:13,858
a useful piece of
information, which says, hey,

565
00:23:13,858 --> 00:23:15,500
you gave me a negative number.

566
00:23:15,500 --> 00:23:17,901
I don't know how to do this.

567
00:23:17,901 --> 00:23:20,400
If it is, in fact, positive,
then we're going to go in here,

568
00:23:20,400 --> 00:23:21,840
but now notice what
we're doing here.

569
00:23:21,840 --> 00:23:23,820
There is the basic thing
we did before, right?

570
00:23:23,820 --> 00:23:25,734
We're checking the end
test and incrementing,

571
00:23:25,734 --> 00:23:28,150
actually I was going to, I
commented that out for a reason

572
00:23:28,150 --> 00:23:29,450
you'll see in a second,
but I, normally I

573
00:23:29,450 --> 00:23:31,658
would keep this on, which
would let me, at each step,

574
00:23:31,658 --> 00:23:33,510
see what it's doing.

575
00:23:33,510 --> 00:23:35,880
If I ran this, it would
print out each step.

576
00:23:35,880 --> 00:23:37,505
Which is helping me
make sure that it's

577
00:23:37,505 --> 00:23:38,772
incrementing the right way.

578
00:23:38,772 --> 00:23:41,230
OK, once it gets to the end of
that, what's it going to do?

579
00:23:41,230 --> 00:23:44,280
It's going to come
down here and, oh.

580
00:23:44,280 --> 00:23:46,609
What's that doing?

581
00:23:46,609 --> 00:23:47,900
Well, I cheated when I started.

582
00:23:47,900 --> 00:23:49,460
I said, somebody's giving
me a perfect square,

583
00:23:49,460 --> 00:23:51,250
I'm looking for the
square root of it.

584
00:23:51,250 --> 00:23:55,402
But suppose I gave this thing
15, and asked it to run.

585
00:23:55,402 --> 00:23:56,610
It'd still give me an answer.

586
00:23:56,610 --> 00:23:59,630
It just would not be the
answer I'm looking for.

587
00:23:59,630 --> 00:24:02,307
So now, in this case, this code
is going to, when we get here,

588
00:24:02,307 --> 00:24:04,640
check, and if you haven't
seen that strange thing there,

589
00:24:04,640 --> 00:24:07,950
that exclamation point in
computer-ese called a bang,

590
00:24:07,950 --> 00:24:13,557
it says if ANS star ANS is
not equal to x, all right?

591
00:24:13,557 --> 00:24:15,140
What's that say, it
says, I've already

592
00:24:15,140 --> 00:24:16,320
gotten to the end
of the loop, I'm now

593
00:24:16,320 --> 00:24:17,760
past where I wanted
to be, and I'm

594
00:24:17,760 --> 00:24:19,760
going to check to make sure
that, in fact, this really

595
00:24:19,760 --> 00:24:20,593
is a perfect square.

596
00:24:20,593 --> 00:24:22,580
If it isn't, print
out something says,

597
00:24:22,580 --> 00:24:25,390
ah, you gave me something
that wasn't a perfect square.

598
00:24:25,390 --> 00:24:32,210
And only if that is true, am I
going to print out the answer.

599
00:24:32,210 --> 00:24:34,810
It's the same computation.

600
00:24:34,810 --> 00:24:36,420
But this is a nice
way of writing it,

601
00:24:36,420 --> 00:24:47,091
often called
defensive programming.

602
00:24:47,091 --> 00:24:49,340
And I think we have lots of
variations on it-- I don't

603
00:24:49,340 --> 00:24:50,965
know about John, what
your favorite is,

604
00:24:50,965 --> 00:24:54,010
for the definition of defensive
programming-- for me it says,

605
00:24:54,010 --> 00:24:56,500
make sure that I'm going
through all possible paths

606
00:24:56,500 --> 00:24:59,930
through the code, make sure
I'm printing out, or returning

607
00:24:59,930 --> 00:25:02,600
if you like, useful information
for each style, sorry,

608
00:25:02,600 --> 00:25:04,790
for each path through
the code, make sure

609
00:25:04,790 --> 00:25:06,490
that for all
possible inputs there

610
00:25:06,490 --> 00:25:08,122
is a path through
the code, or a way

611
00:25:08,122 --> 00:25:10,330
to get through the code,
that does not cause an error

612
00:25:10,330 --> 00:25:11,600
or infinite loop.

613
00:25:11,600 --> 00:25:12,850
What else would you add, John?

614
00:25:12,850 --> 00:25:15,980
PROFESSOR JOHN
GUTTAG: Well, we'll

615
00:25:15,980 --> 00:25:18,320
come back to this
later in the term,

616
00:25:18,320 --> 00:25:22,590
and talk in some detail
about particular techniques.

617
00:25:22,590 --> 00:25:25,230
The basic idea of
defensive programming

618
00:25:25,230 --> 00:25:28,740
is, to assume that A, if you're
getting inputs from a user,

619
00:25:28,740 --> 00:25:31,690
they won't necessarily give
you the input you've asked for,

620
00:25:31,690 --> 00:25:33,270
so if you ask for
a positive number,

621
00:25:33,270 --> 00:25:36,390
don't count on them
giving you one, and B,

622
00:25:36,390 --> 00:25:38,450
if you're using a piece
of a program written

623
00:25:38,450 --> 00:25:41,740
by a programmer
who is not perfect,

624
00:25:41,740 --> 00:25:46,600
perhaps yourself, there could
be mistakes in that program,

625
00:25:46,600 --> 00:25:49,760
and so you write your program
under the assumption that,

626
00:25:49,760 --> 00:25:52,110
not only might the
user make a mistake,

627
00:25:52,110 --> 00:25:54,970
other parts of your program
might make a mistake,

628
00:25:54,970 --> 00:25:57,880
and you just put in
lots of different tests

629
00:25:57,880 --> 00:26:00,060
under the assumption
that you'd rather catch

630
00:26:00,060 --> 00:26:01,980
that something has gone wrong,

631
00:26:01,980 --> 00:26:04,680
then have it go wrong
and not know it.

632
00:26:04,680 --> 00:26:06,960
And we'll talk later in
the term about dozens

633
00:26:06,960 --> 00:26:09,860
of different tricks, but the
main thing to keep in mind

634
00:26:09,860 --> 00:26:14,450
is the general principle
that people are dumb.

635
00:26:14,450 --> 00:26:16,140
And will make mistakes.

636
00:26:16,140 --> 00:26:17,960
And therefore, you
write your programs

637
00:26:17,960 --> 00:26:22,600
so that catastrophes don't occur
when those mistakes are made.

638
00:26:22,600 --> 00:26:24,245
PROFESSOR ERIC GRIMSON: Good.

639
00:26:24,245 --> 00:26:26,120
As John said, we're
going to come back to it.

640
00:26:26,120 --> 00:26:28,100
But that's what,
basically the goal here.

641
00:26:28,100 --> 00:26:30,980
And you saw me put my hands up
when I said stupid programmer?

642
00:26:30,980 --> 00:26:33,360
I've certainly written
code that has this problem,

643
00:26:33,360 --> 00:26:35,930
I've tried to use my own
code that has this problem,

644
00:26:35,930 --> 00:26:38,737
and good to us,
right, good hygiene,

645
00:26:38,737 --> 00:26:40,320
I'm going to use
that word again here,

646
00:26:40,320 --> 00:26:42,600
of getting into the habit
of writing defensive code up

647
00:26:42,600 --> 00:26:44,474
front, it's part of that
collection of things

648
00:26:44,474 --> 00:26:46,710
that you ought to do,
is a great thing to do.

649
00:26:46,710 --> 00:26:48,876
I stress it in
particular because, I

650
00:26:48,876 --> 00:26:50,750
know you're all going
to get into this stage;

651
00:26:50,750 --> 00:26:54,070
you've got a problem set
due in a couple of hours,

652
00:26:54,070 --> 00:26:56,847
you're still writing the code,
you don't want to waste time,

653
00:26:56,847 --> 00:26:59,180
and I'm going to use quotes
on "waste time", doing those

654
00:26:59,180 --> 00:27:01,054
extra things to do the
defensive programming,

655
00:27:01,054 --> 00:27:02,887
you just want to get
the darn thing done.

656
00:27:02,887 --> 00:27:05,220
It's a bad habit to get into,
because when you come back

657
00:27:05,220 --> 00:27:07,100
to it, it may haunt you
later on down the road.

658
00:27:07,100 --> 00:27:08,766
So really get into
that notion of trying

659
00:27:08,766 --> 00:27:11,460
to be defensive as you program.

660
00:27:11,460 --> 00:27:12,052
OK.

661
00:27:12,052 --> 00:27:13,510
The other thing I
want to say here,

662
00:27:13,510 --> 00:27:17,660
is that this style of
program we just wrote,

663
00:27:17,660 --> 00:27:18,910
is actually a very common one.

664
00:27:18,910 --> 00:27:26,550
And we're going to give it
a nice little name, often

665
00:27:26,550 --> 00:27:29,387
referred to as
exhaustive enumeration.

666
00:27:29,387 --> 00:27:30,220
What does that mean?

667
00:27:30,220 --> 00:27:34,872
It says, I'm literally walking
through all possible values

668
00:27:34,872 --> 00:27:38,359
of some parameter, some
element of the computation,

669
00:27:38,359 --> 00:27:40,400
testing everything until
I find the right answer.

670
00:27:40,400 --> 00:27:42,290
All right, so it's,
you know, again, I

671
00:27:42,290 --> 00:27:44,550
can even write that
down, essentially saying,

672
00:27:44,550 --> 00:28:01,305
try all reasonable values
until you find the solution.

673
00:28:01,305 --> 00:28:02,930
And you might say,
well, wait a minute,

674
00:28:02,930 --> 00:28:05,497
isn't that going to
be really expensive?

675
00:28:05,497 --> 00:28:07,830
And the answer is, yeah, I
guess, if you want to search,

676
00:28:07,830 --> 00:28:10,460
you know, all the pages
on Google, one by one,

677
00:28:10,460 --> 00:28:12,290
yes, probably, it's
going to take a while.

678
00:28:12,290 --> 00:28:14,370
But there are an awful lot of
computations for which this

679
00:28:14,370 --> 00:28:15,453
is the right way to do it.

680
00:28:15,453 --> 00:28:17,630
You just want to exhaustively
go through things.

681
00:28:17,630 --> 00:28:19,550
And just to give
you a sense of that,

682
00:28:19,550 --> 00:28:20,740
let me show you an example.

683
00:28:20,740 --> 00:28:25,430
I'm going to change
this, all right?

684
00:28:25,430 --> 00:28:30,340
Nice big number.

685
00:28:30,340 --> 00:28:32,060
You know, computers
are fast these days.

686
00:28:32,060 --> 00:28:33,200
I can make this
even bigger, it's

687
00:28:33,200 --> 00:28:34,991
going to do it fairly
quickly, so it really

688
00:28:34,991 --> 00:28:35,910
is quick to do this.

689
00:28:35,910 --> 00:28:38,400
It doesn't mean that exhaustive
enumeration is a bad idea,

690
00:28:38,400 --> 00:28:40,970
it is often the
right idea to use.

691
00:28:40,970 --> 00:28:42,570
So we've seen one
example of this,

692
00:28:42,570 --> 00:28:44,778
this idea of walking through
all the integers looking

693
00:28:44,778 --> 00:28:46,090
for the square root.

694
00:28:46,090 --> 00:28:47,820
Let's look at some
other examples,

695
00:28:47,820 --> 00:28:52,000
in order to try and see other
ways in which we could do it.

696
00:28:52,000 --> 00:28:52,500
OK.

697
00:28:52,500 --> 00:28:55,770
In particular, let's
go over to here,

698
00:28:55,770 --> 00:28:58,770
and let me show you
a second example.

699
00:28:58,770 --> 00:29:07,750
And let me comment that out.

700
00:29:07,750 --> 00:29:11,230
Here's another problem
that I'd like to solve.

701
00:29:11,230 --> 00:29:13,810
Suppose I want to find all
the divisors of some integer,

702
00:29:13,810 --> 00:29:17,080
I want to figure out
what all the divisors are

703
00:29:17,080 --> 00:29:19,180
that go evenly into it.

704
00:29:19,180 --> 00:29:21,384
Again, same kind of reasoning
says, given some value

705
00:29:21,384 --> 00:29:23,800
x, I happened to pick a small
one here, what's an easy way

706
00:29:23,800 --> 00:29:24,900
to do this?

707
00:29:24,900 --> 00:29:27,430
Well, let's just start at one.

708
00:29:27,430 --> 00:29:29,680
That's my variable I'm
going to change and check.

709
00:29:29,680 --> 00:29:32,010
Does it divide evenly into x?

710
00:29:32,010 --> 00:29:33,410
If it does, print it out.

711
00:29:33,410 --> 00:29:35,470
Move on to the next
one, print it out.

712
00:29:35,470 --> 00:29:37,480
So again, I can do the
same kind of thing here,

713
00:29:37,480 --> 00:29:39,480
you can see that,
in fact, let's just

714
00:29:39,480 --> 00:29:44,960
run it to make sure it
does the right thing, OK?

715
00:29:44,960 --> 00:29:47,452
In fact, if I go
back to the code,

716
00:29:47,452 --> 00:29:48,660
what did I decide to do here?

717
00:29:48,660 --> 00:29:51,920
I say, starting with
an initialization of I,

718
00:29:51,920 --> 00:29:53,736
there's my first
step, as equal to 1,

719
00:29:53,736 --> 00:29:55,360
I'm going to walk
through a little loop

720
00:29:55,360 --> 00:29:57,370
where I check, as
long-- first of all,

721
00:29:57,370 --> 00:29:59,660
as long as I is less than
x, so there's my end test,

722
00:29:59,660 --> 00:30:00,510
I'm going to do something.

723
00:30:00,510 --> 00:30:02,050
And in this case,
the something is,

724
00:30:02,050 --> 00:30:06,255
I'm going to look to see
if I divides x evenly.

725
00:30:06,255 --> 00:30:07,880
So I'll remind you
of that amp-- sorry,

726
00:30:07,880 --> 00:30:11,170
that percent sign there,
that says if x divided by I

727
00:30:11,170 --> 00:30:13,760
has a 0 remainder, because this
gives me back the remainder,

728
00:30:13,760 --> 00:30:16,410
if that's equal to 0,
print something out.

729
00:30:16,410 --> 00:30:19,774
And there's my nice increment.

730
00:30:19,774 --> 00:30:20,940
Simple little piece of code.

731
00:30:20,940 --> 00:30:22,840
Notice again, exactly
the same form:

732
00:30:22,840 --> 00:30:24,340
I picked the thing
I wanted to vary,

733
00:30:24,340 --> 00:30:26,610
I initialized it
outside the loop,

734
00:30:26,610 --> 00:30:28,335
I have a test to
see when I'm done,

735
00:30:28,335 --> 00:30:29,960
and then I've got a
set of instructions

736
00:30:29,960 --> 00:30:31,330
I'm doing every time
inside the loop.

737
00:30:31,330 --> 00:30:33,454
In this case, it's doing
the check on the remainder

738
00:30:33,454 --> 00:30:34,415
and printing them out.

739
00:30:34,415 --> 00:30:36,040
And when I'm done
with the whole thing,

740
00:30:36,040 --> 00:30:38,057
before I end the
increment of the variable,

741
00:30:38,057 --> 00:30:40,390
you know, when I'm done, I'm
just not returning anything

742
00:30:40,390 --> 00:30:42,210
out.

743
00:30:42,210 --> 00:30:42,710
OK.

744
00:30:42,710 --> 00:30:45,320
So now you've seen
two simple examples.

745
00:30:45,320 --> 00:30:47,710
Let me generalize this.

746
00:30:47,710 --> 00:30:51,530
In this case, my incrementer
was just adding 1 to an integer,

747
00:30:51,530 --> 00:30:53,870
it's a pretty
straightforward thing to do.

748
00:30:53,870 --> 00:30:55,870
But you can imagine
thinking about this a little

749
00:30:55,870 --> 00:30:56,369
differently.

750
00:30:56,369 --> 00:30:59,810
If I somehow had a collection,
an ordered collection of all

751
00:30:59,810 --> 00:31:02,770
the integers, from
1 to 10, I could

752
00:31:02,770 --> 00:31:05,020
imagine doing the same thing,
where now what I'm doing

753
00:31:05,020 --> 00:31:07,490
is, I'm starting with the first
element of that collection,

754
00:31:07,490 --> 00:31:09,000
doing something, going
to the next element,

755
00:31:09,000 --> 00:31:10,850
doing something, going to the
next element, doing something,

756
00:31:10,850 --> 00:31:12,933
I'm just walking through
the sequence of elements.

757
00:31:12,933 --> 00:31:13,972
Right?

758
00:31:13,972 --> 00:31:16,180
And I haven't said yet, how
do I get that collection,

759
00:31:16,180 --> 00:31:17,721
but you could
certainly conceptualize

760
00:31:17,721 --> 00:31:21,120
that, if I had that collection,
that would be nice thing to do.

761
00:31:21,120 --> 00:31:23,110
That is a more common pattern.

762
00:31:23,110 --> 00:31:27,650
That is basically saying,
given some collection of data,

763
00:31:27,650 --> 00:31:29,810
I want to have again a
looping mechanism, where

764
00:31:29,810 --> 00:31:32,790
now my process is, walk
through this, the collection,

765
00:31:32,790 --> 00:31:33,880
one element at a time.

766
00:31:33,880 --> 00:31:41,070
And for that, we have
a particular construct,

767
00:31:41,070 --> 00:31:42,360
called a FOR loop.

768
00:31:42,360 --> 00:31:44,424
It's going to do
exactly that for us.

769
00:31:44,424 --> 00:31:46,090
It's going to be more
general than this,

770
00:31:46,090 --> 00:31:47,020
and we're going to
come back to that,

771
00:31:47,020 --> 00:31:48,630
in fact, Professor Guttag's
going to pick this up

772
00:31:48,630 --> 00:31:50,713
in a couple of lectures,
but we can talk right now

773
00:31:50,713 --> 00:31:51,750
about the basic form.

774
00:31:51,750 --> 00:31:54,240
The form of a FOR
loop says, FOR,

775
00:31:54,240 --> 00:31:56,240
and I'm going to put
little angle braces in here

776
00:31:56,240 --> 00:31:57,614
again, to say,
for some variable,

777
00:31:57,614 --> 00:32:08,200
like a name I want to get
to it, in some collection,

778
00:32:08,200 --> 00:32:14,470
and then I have a block of code.

779
00:32:14,470 --> 00:32:17,250
And what it's saying
semantically is,

780
00:32:17,250 --> 00:32:19,560
using that variable
as my placeholder,

781
00:32:19,560 --> 00:32:21,140
have it walk through
this collection,

782
00:32:21,140 --> 00:32:23,490
starting at the first thing,
execute that code, then

783
00:32:23,490 --> 00:32:26,480
the next thing, execute
that code, and so on.

784
00:32:26,480 --> 00:32:29,450
One of the advantages
of this is,

785
00:32:29,450 --> 00:32:32,050
that I don't have to
worry about explicitly

786
00:32:32,050 --> 00:32:33,624
updating my variable.

787
00:32:33,624 --> 00:32:35,040
That happens for
me automatically.

788
00:32:35,040 --> 00:32:36,530
And that's very
nice, because this

789
00:32:36,530 --> 00:32:39,750
allows me to be sure that my
FOR loop is going to terminate.

790
00:32:39,750 --> 00:32:43,562
And because, as long as
this collection is finite,

791
00:32:43,562 --> 00:32:45,270
this thing is just
going to walk through.

792
00:32:45,270 --> 00:32:46,760
All right?

793
00:32:46,760 --> 00:32:48,310
So, if I show you,
for example, I'm

794
00:32:48,310 --> 00:32:53,030
going to comment this one
out in the usual manner,

795
00:32:53,030 --> 00:33:03,860
and let's look at
uncommenting that, there

796
00:33:03,860 --> 00:33:07,000
is the same piece of code.

797
00:33:07,000 --> 00:33:09,252
Now, I slung something by
you, or snuck something

798
00:33:09,252 --> 00:33:10,710
by you, which is,
I hadn't said how

799
00:33:10,710 --> 00:33:14,610
to generate the set of
integers from 1 to 10.

800
00:33:14,610 --> 00:33:16,782
So, range is a built-in
Python function.

801
00:33:16,782 --> 00:33:18,490
I'm going to come back
to it in a second.

802
00:33:18,490 --> 00:33:20,240
For now, just think
of it as saying, it

803
00:33:20,240 --> 00:33:25,690
gives you all the integers from
1 up to, but not including, x.

804
00:33:25,690 --> 00:33:26,642
OK.

805
00:33:26,642 --> 00:33:27,850
But now you can see the form.

806
00:33:27,850 --> 00:33:30,360
This now says, OK, let I start
as the first thing in there,

807
00:33:30,360 --> 00:33:32,760
which is 1, and then do
exactly as I did before,

808
00:33:32,760 --> 00:33:34,590
the same thing, but
notice I don't need

809
00:33:34,590 --> 00:33:36,317
to say how to increment it.

810
00:33:36,317 --> 00:33:38,970
It's happening
automatically for me.

811
00:33:38,970 --> 00:33:40,360
OK.

812
00:33:40,360 --> 00:33:45,230
In fact, if I run it,
it does the same thing,

813
00:33:45,230 --> 00:33:47,860
which is what I would expect.

814
00:33:47,860 --> 00:33:49,650
OK.

815
00:33:49,650 --> 00:33:54,670
Now, the advantage of the FOR,
as I said, is that it has,

816
00:33:54,670 --> 00:33:57,470
then, if you like, a
cleaner way of reading it.

817
00:33:57,470 --> 00:33:59,552
I don't have to worry
about, do I initialize it,

818
00:33:59,552 --> 00:34:01,510
did I forget to initialize
it outside the loop,

819
00:34:01,510 --> 00:34:03,724
it happens automatically
just by the syntax of it,

820
00:34:03,724 --> 00:34:06,140
right there, that's going to
start with the first element.

821
00:34:06,140 --> 00:34:07,220
I don't have to
worry about, did I

822
00:34:07,220 --> 00:34:08,678
remember to put
the incrementer in,

823
00:34:08,678 --> 00:34:11,230
it's going to automatically
walk it's way through there.

824
00:34:11,230 --> 00:34:13,630
Second advantage of the FOR
is, that right now, we're

825
00:34:13,630 --> 00:34:15,671
thinking about it just as
a sequence of integers.

826
00:34:15,671 --> 00:34:17,860
We could imagine it's just
counting its way through.

827
00:34:17,860 --> 00:34:19,401
But we're going to
see, very shortly,

828
00:34:19,401 --> 00:34:21,670
that in fact those collections
could be arbitrary.

829
00:34:21,670 --> 00:34:23,670
We're going to have other
ways of building them,

830
00:34:23,670 --> 00:34:25,661
but it could be a collection
of all the primes.

831
00:34:25,661 --> 00:34:26,160
Hm.

832
00:34:26,160 --> 00:34:27,970
There's an interesting
thing to do.

833
00:34:27,970 --> 00:34:30,770
It could be a collection of,
ah, you know, I don't know,

834
00:34:30,770 --> 00:34:32,690
batting averages of
somebody or other.

835
00:34:32,690 --> 00:34:34,186
It could be
arbitrary collections

836
00:34:34,186 --> 00:34:35,810
that you've come up
with in other ways.

837
00:34:35,810 --> 00:34:38,090
The FOR is, again, going to let
you walk through that thing.

838
00:34:38,090 --> 00:34:39,680
So it does not have
to be something

839
00:34:39,680 --> 00:34:43,790
that could be described
procedurally, such as add 1

840
00:34:43,790 --> 00:34:45,230
just to the previous element.

841
00:34:45,230 --> 00:34:47,470
It could be any
arbitrary collection.

842
00:34:47,470 --> 00:34:48,970
And if I were to
use that again, I'd

843
00:34:48,970 --> 00:34:50,570
just put it on your
handout, I could go back

844
00:34:50,570 --> 00:34:52,403
and rewrite that thing
that I had previously

845
00:34:52,403 --> 00:34:55,020
for finding the square roots
of the perfect squares,

846
00:34:55,020 --> 00:34:57,970
just using the FOR loop.

847
00:34:57,970 --> 00:34:58,976
OK.

848
00:34:58,976 --> 00:35:01,100
What I want to do, though,
is go on to-- or, sorry,

849
00:35:01,100 --> 00:35:07,730
go back to-- my divisor example.
[UNINTELLIGIBLE PHRASE] OK.

850
00:35:07,730 --> 00:35:08,230
Try again.

851
00:35:08,230 --> 00:35:09,720
I've got a number, I want
to find the divisors.

852
00:35:09,720 --> 00:35:11,220
Right now, what my
code is doing is,

853
00:35:11,220 --> 00:35:14,520
it's printing them up
for me, which is useful.

854
00:35:14,520 --> 00:35:17,430
But imagine I actually wanted
to gather them together.

855
00:35:17,430 --> 00:35:20,054
I wanted to collect them, so I
could do something with them.

856
00:35:20,054 --> 00:35:21,220
I might want to add them up.

857
00:35:21,220 --> 00:35:22,440
Might want to multiply
them together.

858
00:35:22,440 --> 00:35:24,814
Might want to do, I don't
know, something else with them,

859
00:35:24,814 --> 00:35:27,760
find common divisors, of
things by looking at them.

860
00:35:27,760 --> 00:35:30,092
I need, in fact, a
way to make explicit,

861
00:35:30,092 --> 00:35:31,550
what I can't do
that with range, is

862
00:35:31,550 --> 00:35:34,970
I need a way to collect
things together.

863
00:35:34,970 --> 00:35:37,520
And that's going to be the
first of our more compound data

864
00:35:37,520 --> 00:35:40,480
structures, and we have
exactly such a structure,

865
00:35:40,480 --> 00:35:49,680
and it's called a tuple.

866
00:35:49,680 --> 00:35:59,884
This is an ordered
sequence of elements.

867
00:35:59,884 --> 00:36:01,550
Now, I'm going to
actually add something

868
00:36:01,550 --> 00:36:03,675
to it that's going to make
sense in a little while,

869
00:36:03,675 --> 00:36:09,506
or in a couple of lectures,
which is, it is immutable.

870
00:36:09,506 --> 00:36:12,130
Meaning, I cannot change it, and
we'll see why that's important

871
00:36:12,130 --> 00:36:12,629
later on.

872
00:36:12,629 --> 00:36:17,730
But for now, tuple is this
ordered sequence of structures.

873
00:36:17,730 --> 00:36:18,500
OK.

874
00:36:18,500 --> 00:36:20,600
And how do I create them?

875
00:36:20,600 --> 00:36:32,370
Well, the representation is,
following a square bracket,

876
00:36:32,370 --> 00:36:35,150
followed by a sequence of
elements, separated by commas,

877
00:36:35,150 --> 00:36:38,074
followed by a closed
square bracket.

878
00:36:38,074 --> 00:36:39,490
And that is literally
what I said,

879
00:36:39,490 --> 00:36:41,860
it is an ordered
sequence of elements,

880
00:36:41,860 --> 00:36:44,080
you can see where they are.

881
00:36:44,080 --> 00:36:44,580
OK?

882
00:36:44,580 --> 00:36:46,204
So, let me do a little
example of this.

883
00:36:46,204 --> 00:36:53,140
If I go back over here,
let's define-- er,

884
00:36:53,140 --> 00:37:02,150
can't type-- I can look
at the value of test,

885
00:37:02,150 --> 00:37:03,960
it's an ordered sequence.

886
00:37:03,960 --> 00:37:05,900
I need to get
elements out of it.

887
00:37:05,900 --> 00:37:07,490
So again, I have a
way of doing that.

888
00:37:07,490 --> 00:37:12,330
In particular, I can ask for
the zeroth element of test.

889
00:37:12,330 --> 00:37:16,230
OK, notice, I'm putting a
square bracket around it,

890
00:37:16,230 --> 00:37:18,800
and it gives me-- I know
this sounds confusing,

891
00:37:18,800 --> 00:37:21,150
but this is a long tradition,
it gives me-- ah, yes.

892
00:37:21,150 --> 00:37:24,820
STUDENT: [UNINTELLIGIBLE]

893
00:37:24,820 --> 00:37:31,619
PROFESSOR ERIC GRIMSON: Sorry?

894
00:37:31,619 --> 00:37:32,660
STUDENT: [UNINTELLIGIBLE]

895
00:37:32,660 --> 00:37:33,230
PROFESSOR ERIC GRIMSON:
I created a list here?

896
00:37:33,230 --> 00:37:35,120
Ah, thank you.

897
00:37:35,120 --> 00:37:37,850
I'm glad you guys
are on top of it.

898
00:37:37,850 --> 00:37:40,460
You're saying I want that.

899
00:37:40,460 --> 00:37:43,040
Is that right, John?

900
00:37:43,040 --> 00:37:43,720
Yes?

901
00:37:43,720 --> 00:37:44,220
OK.

902
00:37:44,220 --> 00:37:45,549
Sorry.

903
00:37:45,549 --> 00:37:48,090
You're going to see why this
was a mistake in a little while.

904
00:37:48,090 --> 00:37:49,470
I did not want to
make a list, I wanted

905
00:37:49,470 --> 00:37:51,303
to create a tuple thank
you for catching it.

906
00:37:51,303 --> 00:37:53,704
I want parens, not
square brackets there.

907
00:37:53,704 --> 00:37:56,120
You'll also see in a little
while why both of these things

908
00:37:56,120 --> 00:37:58,430
would work this way, but
it's not what I wanted.

909
00:37:58,430 --> 00:37:59,400
OK?

910
00:37:59,400 --> 00:38:00,900
So I guess I should
go back, and let

911
00:38:00,900 --> 00:38:09,720
me do this correctly this way.

912
00:38:09,720 --> 00:38:13,470
Again, I can look at
test, and I guess test now

913
00:38:13,470 --> 00:38:16,450
if I want to get the
element out-- angle

914
00:38:16,450 --> 00:38:18,020
bracket or square bracket?

915
00:38:18,020 --> 00:38:21,395
I still want square bracket,
that's what I thought-- OK.

916
00:38:21,395 --> 00:38:22,770
Now I can go back
to where I was,

917
00:38:22,770 --> 00:38:24,520
which is a strange
piece of history, which

918
00:38:24,520 --> 00:38:27,090
is, we start counting at 0.

919
00:38:27,090 --> 00:38:29,310
So the-- I hate to
say it this way,

920
00:38:29,310 --> 00:38:33,520
the first element of this tuple
is at position 0, or index 0,

921
00:38:33,520 --> 00:38:39,240
OK?-- so I can get the zeroth
one out, I can get, if I do 2,

922
00:38:39,240 --> 00:38:42,710
I get the third thing out,
because it goes 0, 1, 2--

923
00:38:42,710 --> 00:38:46,670
notice, however, if I do
something that tries to go

924
00:38:46,670 --> 00:38:53,272
outside the length of the tuple
it complains, which is right.

925
00:38:53,272 --> 00:38:54,980
Tuples? also have
another nice structure,

926
00:38:54,980 --> 00:38:56,854
which is, I can go the
other direction, which

927
00:38:56,854 --> 00:39:02,130
is, if I want to get the
last element of that tuple

928
00:39:02,130 --> 00:39:03,256
I give it a negative index.

929
00:39:03,256 --> 00:39:05,713
So, imagine, you think of it
as, is it starting right, just

930
00:39:05,713 --> 00:39:07,160
before the beginning
of the thing,

931
00:39:07,160 --> 00:39:09,010
if I give it a 0 it's going
to take the first one,

932
00:39:09,010 --> 00:39:11,093
if I give it a 1, it's
going to take the next one,

933
00:39:11,093 --> 00:39:14,010
but I can go the other
direction, if I give it a -1,

934
00:39:14,010 --> 00:39:15,830
it picks up the last
element of the tuple.

935
00:39:15,830 --> 00:39:21,760
And again, I can go -2, go back.

936
00:39:21,760 --> 00:39:27,250
So this is what we
would call selection.

937
00:39:27,250 --> 00:39:31,650
We can do things like
foo of 0 to get out

938
00:39:31,650 --> 00:39:34,600
the particular element.

939
00:39:34,600 --> 00:39:38,110
I can also pick up
pieces of that tuple.

940
00:39:38,110 --> 00:39:40,850
Again I want to show
you the format here.

941
00:39:40,850 --> 00:39:45,360
If I give it this
strange expression,

942
00:39:45,360 --> 00:39:47,880
this is saying I want to
get the piece of the tuple

943
00:39:47,880 --> 00:39:51,300
starting at index 1, it's
going to be the second element,

944
00:39:51,300 --> 00:39:53,750
and going up to but
not including index 3.

945
00:39:53,750 --> 00:39:58,760
And it gives me back that piece.

946
00:39:58,760 --> 00:40:02,840
Actually a copy of that
piece of the tuple.

947
00:40:02,840 --> 00:40:13,620
This is called slicing.

948
00:40:13,620 --> 00:40:15,190
And then just to complete this.

949
00:40:15,190 --> 00:40:18,150
Two other nice things you
can do with slices are you

950
00:40:18,150 --> 00:40:22,510
can get the beginning
or the end of tuple.

951
00:40:22,510 --> 00:40:25,200
So, for example, if I say TEST
and I don't give it a start

952
00:40:25,200 --> 00:40:28,300
but I give it an end, then
it gives me all the elements

953
00:40:28,300 --> 00:40:30,720
up to that point.

954
00:40:30,720 --> 00:40:32,600
And I can obviously
do the other direction

955
00:40:32,600 --> 00:40:42,410
which is I can say skip to index
2 and all the remaining pieces.

956
00:40:42,410 --> 00:40:45,310
This lets me slice
out, if you like,

957
00:40:45,310 --> 00:40:48,370
the front part or back part or
a middle part of the tuple as I

958
00:40:48,370 --> 00:40:50,770
go along.

959
00:40:50,770 --> 00:40:55,090
What in the world does that have
to do with my divisor example?

960
00:40:55,090 --> 00:40:57,800
Well, actually, before I do that
let me in fact fill in a piece

961
00:40:57,800 --> 00:40:57,940
here.

962
00:40:57,940 --> 00:41:00,610
Which is remember I said range
we could think of conceptually

963
00:41:00,610 --> 00:41:07,330
as a tuple -- or sorry as
a sequence of these things.

964
00:41:07,330 --> 00:41:09,610
In fact it gives me
back, now I hate this,

965
00:41:09,610 --> 00:41:12,390
it's actually a list
it's not a tuple.

966
00:41:12,390 --> 00:41:13,960
But for now think
of it as giving you

967
00:41:13,960 --> 00:41:17,400
back an explicit version of
that representation of all

968
00:41:17,400 --> 00:41:18,079
those elements.

969
00:41:18,079 --> 00:41:20,120
You'll see why I'm going
to make that distinction

970
00:41:20,120 --> 00:41:22,510
in a couple of lectures.

971
00:41:22,510 --> 00:41:23,450
All right.

972
00:41:23,450 --> 00:41:25,690
What does this have to do
with my divisor example?

973
00:41:25,690 --> 00:41:28,560
This says I can make tuples,
but imagine now going back

974
00:41:28,560 --> 00:41:31,360
to my divisor example
and I want to gather up

975
00:41:31,360 --> 00:41:33,560
the elements as I go along.

976
00:41:33,560 --> 00:41:36,540
I ought to be able to do
that by in fact just adding

977
00:41:36,540 --> 00:41:38,040
the pieces in.

978
00:41:38,040 --> 00:41:42,590
And that's what I'm
going to do over here.

979
00:41:42,590 --> 00:41:56,090
Which is, let me comment that
out, let me uncomment that.

980
00:41:56,090 --> 00:41:58,290
And I guess I need the
same thing here, right?

981
00:41:58,290 --> 00:42:04,720
I need parens not, thank you.

982
00:42:04,720 --> 00:42:06,700
You can tell I'm an
old time list packer.

983
00:42:06,700 --> 00:42:08,880
I really do love these things.

984
00:42:08,880 --> 00:42:15,150
And is that right, John?

985
00:42:15,150 --> 00:42:17,280
OK, so my apologies that
your handout is wrong.

986
00:42:17,280 --> 00:42:19,155
I did not think to check
about the difference

987
00:42:19,155 --> 00:42:20,511
between these things.

988
00:42:20,511 --> 00:42:22,010
Nonetheless, having
done that, let's

989
00:42:22,010 --> 00:42:24,170
look at what I'm going to do.

990
00:42:24,170 --> 00:42:26,570
I now want to run
a loop where I need

991
00:42:26,570 --> 00:42:28,075
to collect things together.

992
00:42:28,075 --> 00:42:29,450
I'm going to give
a name to that.

993
00:42:29,450 --> 00:42:31,616
And what you see there is
I'm going to call divisors

994
00:42:31,616 --> 00:42:35,170
initially an empty tuple,
something has nothing in it.

995
00:42:35,170 --> 00:42:35,912
Right here.

996
00:42:35,912 --> 00:42:37,870
And then I'm going to
run through the same loop

997
00:42:37,870 --> 00:42:40,320
as before, going through this
set of things, doing the check.

998
00:42:40,320 --> 00:42:41,778
Now what I'd like
to do, every time

999
00:42:41,778 --> 00:42:44,330
I find a divisor I'd like
to gather it together.

1000
00:42:44,330 --> 00:42:49,360
So I'm going to create a tuple
of one element, the value of i.

1001
00:42:49,360 --> 00:42:51,630
And then, ah, cool.

1002
00:42:51,630 --> 00:42:54,410
Here's that addition operation
that's badly overloaded.

1003
00:42:54,410 --> 00:42:56,990
This is why Professor
Guttag likes and I don't.

1004
00:42:56,990 --> 00:43:01,472
Because given that this is
a tuple and that's a tuple,

1005
00:43:01,472 --> 00:43:02,680
I can just add them together.

1006
00:43:02,680 --> 00:43:06,820
That is concatenate them, if
you like, one on the end of it.

1007
00:43:06,820 --> 00:43:09,500
And if I keep doing that,
when I'm done divisor

1008
00:43:09,500 --> 00:43:10,830
will be a collection of things.

1009
00:43:10,830 --> 00:43:15,330
So let me just run it.

1010
00:43:15,330 --> 00:43:17,330
All right.

1011
00:43:17,330 --> 00:43:20,825
This is what I get
for trying to --

1012
00:43:20,825 --> 00:43:22,200
STUDENT There
should be a comment

1013
00:43:22,200 --> 00:43:22,660
after the i in parentheses.

1014
00:43:22,660 --> 00:43:24,690
PROFESSOR ERIC
GRIMSON: Thank you.

1015
00:43:24,690 --> 00:43:26,240
Right there.

1016
00:43:26,240 --> 00:43:31,510
All right, we'll try this again.

1017
00:43:31,510 --> 00:43:35,695
OK.

1018
00:43:35,695 --> 00:43:37,070
And there are the
set of devices.

1019
00:43:37,070 --> 00:43:37,570
Thank you.

1020
00:43:37,570 --> 00:43:38,120
Who did that?

1021
00:43:38,120 --> 00:43:41,080
Somebody gets, no?

1022
00:43:41,080 --> 00:43:41,610
Yours?

1023
00:43:41,610 --> 00:43:42,680
Thank you.

1024
00:43:42,680 --> 00:43:44,351
Nice catch too by the way.

1025
00:43:44,351 --> 00:43:46,600
All right, so now that you
can see that I can screw up

1026
00:43:46,600 --> 00:43:47,876
programming, which I just did.

1027
00:43:47,876 --> 00:43:49,000
But we fixed it on the fly.

1028
00:43:49,000 --> 00:43:49,840
Thank you.

1029
00:43:49,840 --> 00:43:51,160
What have we done?

1030
00:43:51,160 --> 00:43:54,220
We've now got a way of
collecting things together,

1031
00:43:54,220 --> 00:43:55,110
right?

1032
00:43:55,110 --> 00:43:58,000
And this is the first version
of something we'd like to use.

1033
00:43:58,000 --> 00:43:59,767
Now that I've gotten
that bound as a name,

1034
00:43:59,767 --> 00:44:01,350
I could go in and
do things with that.

1035
00:44:01,350 --> 00:44:04,030
I could go in and say give
me the fourth divisor,

1036
00:44:04,030 --> 00:44:06,260
give me the second
through fifth divisor.

1037
00:44:06,260 --> 00:44:08,800
Again as I suggested if
I've got two integers

1038
00:44:08,800 --> 00:44:10,260
and I want to find
common divisors

1039
00:44:10,260 --> 00:44:11,910
I could take those two
lists and walk through them.

1040
00:44:11,910 --> 00:44:12,480
I shouldn't say list,
those two tuples,

1041
00:44:12,480 --> 00:44:15,680
and walk through them to find
the pieces that match up.

1042
00:44:15,680 --> 00:44:19,151
So I've got a way now of
gathering data together.

1043
00:44:19,151 --> 00:44:21,150
The last thing I want to
do is to say all right,

1044
00:44:21,150 --> 00:44:25,890
now that we've got this idea
of being able to collect things

1045
00:44:25,890 --> 00:44:29,010
into collections, we've got
the ability now to use looping

1046
00:44:29,010 --> 00:44:33,680
structures as we did before
but we can walk down then doing

1047
00:44:33,680 --> 00:44:37,580
things to them, where else might
we have this need to do things

1048
00:44:37,580 --> 00:44:40,290
with looping structures?

1049
00:44:40,290 --> 00:44:43,210
And I'm going to suggest
you've already seen it.

1050
00:44:43,210 --> 00:44:45,570
What's a string?

1051
00:44:45,570 --> 00:44:49,540
Well at some level it is an
ordered sequence of characters.

1052
00:44:49,540 --> 00:44:51,090
Right?

1053
00:44:51,090 --> 00:44:53,170
Now it is not represented
this same way.

1054
00:44:53,170 --> 00:44:55,130
You don't see strings
inside these open parens

1055
00:44:55,130 --> 00:44:56,330
and closed parens.

1056
00:44:56,330 --> 00:44:59,650
You don't see strings
with commas between them,

1057
00:44:59,650 --> 00:45:01,860
but it has the same
kind of property.

1058
00:45:01,860 --> 00:45:04,440
It is in ordered
sequence of characters.

1059
00:45:04,440 --> 00:45:07,019
We'd like to do the
same thing with strings.

1060
00:45:07,019 --> 00:45:09,310
That is we'd like to be able
to get pieces of them out.

1061
00:45:09,310 --> 00:45:11,450
We'd like to be able add them
together or concatenate them

1062
00:45:11,450 --> 00:45:11,949
together.

1063
00:45:11,949 --> 00:45:13,580
We'd like to be
able to slice them.

1064
00:45:13,580 --> 00:45:17,710
And in fact we can.

1065
00:45:17,710 --> 00:45:33,150
So strings also support things
like selection, slicing,

1066
00:45:33,150 --> 00:45:35,310
and a set of other
parameters, other properties.

1067
00:45:35,310 --> 00:45:36,720
And let's just look at that.

1068
00:45:36,720 --> 00:45:47,850
Again if I go back here,
let me comment this out.

1069
00:45:47,850 --> 00:45:55,810
Right here are a pair of strings
that I've set up, s 1 and s 2.

1070
00:45:55,810 --> 00:45:57,090
Let me just run these.

1071
00:45:57,090 --> 00:46:00,310
We can go back over here.

1072
00:46:00,310 --> 00:46:03,530
So I can see the value
of s 1, it's a string.

1073
00:46:03,530 --> 00:46:07,501
I can do things
like s 1 and s 2.

1074
00:46:07,501 --> 00:46:09,750
As we saw before, it simply
concatenates them together

1075
00:46:09,750 --> 00:46:11,450
and gives me back
a longer string.

1076
00:46:11,450 --> 00:46:13,940
But I can also ask
for parts of this.

1077
00:46:13,940 --> 00:46:20,720
So I can, for example, say
give me the first element

1078
00:46:20,720 --> 00:46:23,720
of string 1, s 1.

1079
00:46:23,720 --> 00:46:25,951
Ah, that's exactly
what we would have

1080
00:46:25,951 --> 00:46:28,200
thought if this was represented
as an ordered sequence

1081
00:46:28,200 --> 00:46:29,030
of things.

1082
00:46:29,030 --> 00:46:32,190
Again I should have said
first, index 0, the first one.

1083
00:46:32,190 --> 00:46:34,170
I can similarly
go in and say I'd

1084
00:46:34,170 --> 00:46:41,442
like all the things between
index 2 and index 4.

1085
00:46:41,442 --> 00:46:42,900
And again, remember
what that does.

1086
00:46:42,900 --> 00:46:44,350
Index 2 says start a 0.

1087
00:46:44,350 --> 00:46:44,850
1, 2.

1088
00:46:44,850 --> 00:46:47,430
So a, b, c.

1089
00:46:47,430 --> 00:46:49,600
And then it goes up to
but not including index 4

1090
00:46:49,600 --> 00:46:53,070
so it gets c and d
and then it stops.

1091
00:46:53,070 --> 00:46:55,690
I can similarly, just as
I did with the tuples,

1092
00:46:55,690 --> 00:47:01,372
I can ask for everything
up to some point

1093
00:47:01,372 --> 00:47:03,455
or I can ask for everything
starting at some point

1094
00:47:03,455 --> 00:47:06,650
and carrying on.

1095
00:47:06,650 --> 00:47:09,410
Now what you're seeing
here then is the beginning

1096
00:47:09,410 --> 00:47:11,660
of complex data structures.

1097
00:47:11,660 --> 00:47:13,910
And the nice thing
is that there's

1098
00:47:13,910 --> 00:47:14,990
a shared behavior there.

1099
00:47:14,990 --> 00:47:17,940
Just as I can have tuples as an
ordered collection of things,

1100
00:47:17,940 --> 00:47:20,390
strings behave as an ordered
collection of things.

1101
00:47:20,390 --> 00:47:23,550
So I can start thinking about
doing manipulation on strings.

1102
00:47:23,550 --> 00:47:27,004
I can concatenate them together,
I can find pieces inside

1103
00:47:27,004 --> 00:47:28,920
of them, I could actually
do things with them.

1104
00:47:28,920 --> 00:47:30,920
And let me show you just
a simple little example

1105
00:47:30,920 --> 00:47:35,960
of something I might want to do.

1106
00:47:35,960 --> 00:47:42,800
Suppose I take, I better
comment this one out

1107
00:47:42,800 --> 00:47:44,350
or it's going to spit it out.

1108
00:47:44,350 --> 00:47:47,070
Let me comment that out.

1109
00:47:47,070 --> 00:47:50,720
Suppose I take a number.

1110
00:47:50,720 --> 00:47:53,460
I'd like to add up all the
digits inside of the number.

1111
00:47:53,460 --> 00:47:55,300
I can use the tools
I've just described

1112
00:47:55,300 --> 00:47:56,120
in order to capture that.

1113
00:47:56,120 --> 00:47:57,244
So what would I want to do?

1114
00:47:57,244 --> 00:47:59,410
I'd like to somehow walk
down each of the digits

1115
00:47:59,410 --> 00:48:02,330
one at a time and add them up.

1116
00:48:02,330 --> 00:48:04,610
Ah, that's a looping
mechanism, right?

1117
00:48:04,610 --> 00:48:06,770
I need to have some way
of walking through them.

1118
00:48:06,770 --> 00:48:08,954
An easy way to do it
would be inside of a FOR.

1119
00:48:08,954 --> 00:48:10,120
And what would I like to do?

1120
00:48:10,120 --> 00:48:12,280
Well I need to take
that number and I'm

1121
00:48:12,280 --> 00:48:13,890
going to turn it into a string.

1122
00:48:13,890 --> 00:48:16,530
So notice what I'm
going to do right here.

1123
00:48:16,530 --> 00:48:19,580
I take that number and
convert it into a string.

1124
00:48:19,580 --> 00:48:22,510
That's an example of that type
conversion we did earlier on.

1125
00:48:22,510 --> 00:48:25,540
By doing that it makes it
possible for me to treat it

1126
00:48:25,540 --> 00:48:27,732
as an ordered sequence
of characters.

1127
00:48:27,732 --> 00:48:29,190
And so what's the
loop going to do?

1128
00:48:29,190 --> 00:48:30,606
It's going to say
FOR c, which was

1129
00:48:30,606 --> 00:48:32,730
my name for the
character in that string.

1130
00:48:32,730 --> 00:48:34,487
That means starting
at the first one,

1131
00:48:34,487 --> 00:48:35,820
I'm going to do something to it.

1132
00:48:35,820 --> 00:48:37,040
And what am I'm going to do?

1133
00:48:37,040 --> 00:48:38,680
I'm going to take
that character,

1134
00:48:38,680 --> 00:48:43,886
convert it back into an integer,
and add it into some digits.

1135
00:48:43,886 --> 00:48:45,510
And I've done a little
short hand here,

1136
00:48:45,510 --> 00:48:47,550
which is I should have
said some digits is

1137
00:48:47,550 --> 00:48:49,962
equal to some digits plus this.

1138
00:48:49,962 --> 00:48:51,420
But that little
short hand there is

1139
00:48:51,420 --> 00:48:52,700
doing exactly the same thing.

1140
00:48:52,700 --> 00:48:54,910
It is adding that
value into some digits

1141
00:48:54,910 --> 00:48:57,734
and putting it back or signing
it back into some digits.

1142
00:48:57,734 --> 00:48:59,400
And I'll walk through
that loop and when

1143
00:48:59,400 --> 00:49:04,140
I'm done I can print out
the total thing does.

1144
00:49:04,140 --> 00:49:10,470
And if I do that, I get
out what I would expect.

1145
00:49:10,470 --> 00:49:12,800
So what have I done?

1146
00:49:12,800 --> 00:49:15,900
We've now generalized
the idea of iteration

1147
00:49:15,900 --> 00:49:17,354
into this little pattern.

1148
00:49:17,354 --> 00:49:19,770
Again as I said this is my
version of it, but you can see,

1149
00:49:19,770 --> 00:49:21,590
every one of the examples
we've used so far

1150
00:49:21,590 --> 00:49:22,999
has that pattern to it.

1151
00:49:22,999 --> 00:49:24,790
Figure out what I'm
trying to walk through.

1152
00:49:24,790 --> 00:49:26,920
What's the collection of things
I'm trying to walk through.

1153
00:49:26,920 --> 00:49:28,590
Figure out what I want
to do at each stage.

1154
00:49:28,590 --> 00:49:29,780
Figure out what the end test is.

1155
00:49:29,780 --> 00:49:31,821
Figure out what I'm going
to do at the end of it.

1156
00:49:31,821 --> 00:49:32,930
I can write it explicitly.

1157
00:49:32,930 --> 00:49:34,852
I can write it
inside of a FOR loop.

1158
00:49:34,852 --> 00:49:36,310
And we've started
to add, and we'll

1159
00:49:36,310 --> 00:49:40,142
see a lot more of this, examples
of collections of structures

1160
00:49:40,142 --> 00:49:42,100
so that we don't just
have to do something that

1161
00:49:42,100 --> 00:49:44,660
can be easily described as
walking through a set of things

1162
00:49:44,660 --> 00:49:47,342
but can actually be a collection
that you walk through.

1163
00:49:47,342 --> 00:49:49,050
The last thing I want
to point out to you

1164
00:49:49,050 --> 00:49:54,150
is, I started out
with this list.

1165
00:49:54,150 --> 00:49:58,230
I haven't added anything
to the list, right?

1166
00:49:58,230 --> 00:50:00,979
I mean I've got a different
kind of looping mechanism.

1167
00:50:00,979 --> 00:50:02,770
I guess I should say
that's not quite true.

1168
00:50:02,770 --> 00:50:04,940
I've added the ability
to have more complex data

1169
00:50:04,940 --> 00:50:06,820
structures here.

1170
00:50:06,820 --> 00:50:08,570
But I dropped a hint
in the first lecture

1171
00:50:08,570 --> 00:50:10,319
about what you could
computer with things.

1172
00:50:10,319 --> 00:50:13,050
In fact if you think for
a second about that list,

1173
00:50:13,050 --> 00:50:15,060
you could ask what can
I compute with just

1174
00:50:15,060 --> 00:50:17,120
that set of constructs?

1175
00:50:17,120 --> 00:50:19,810
And the answer is
basically anything.

1176
00:50:19,810 --> 00:50:21,980
This is an example
of what is referred

1177
00:50:21,980 --> 00:50:26,500
to frequently as being a
Turing complete language.

1178
00:50:26,500 --> 00:50:29,360
That is to say with just those
set of constructs, anything

1179
00:50:29,360 --> 00:50:32,110
you can describe
algorithmically you can compute

1180
00:50:32,110 --> 00:50:34,230
with that set of constructs.

1181
00:50:34,230 --> 00:50:36,170
So there's good
news and bad news.

1182
00:50:36,170 --> 00:50:38,240
The good news is it
sounds like we're done.

1183
00:50:38,240 --> 00:50:41,570
Class is cancelled until final
exam because this is all you

1184
00:50:41,570 --> 00:50:43,150
need to know, right?

1185
00:50:43,150 --> 00:50:44,900
The bad news is of
course that's not true.

1186
00:50:44,900 --> 00:50:48,014
The real issue is to figure
out how to build constructs out

1187
00:50:48,014 --> 00:50:49,680
of this that tackle
particular problems,

1188
00:50:49,680 --> 00:50:52,120
but the fundamental
basics of computation

1189
00:50:52,120 --> 00:50:55,260
are just captured in
that set of mechanisms.

1190
00:50:55,260 --> 00:50:57,280
All right, we'll
see you next time.

1191
00:50:57,280 --> 00:50:59,158