1
00:00:00,000 --> 00:00:02,400
The following content is
provided under a Creative

2
00:00:02,400 --> 00:00:03,830
Commons license.

3
00:00:03,830 --> 00:00:06,840
Your support will help MIT
OpenCourseware continue to

4
00:00:06,840 --> 00:00:10,510
offer high-quality educational
resources for free.

5
00:00:10,510 --> 00:00:13,390
To make a donation, or view
additional materials from

6
00:00:13,390 --> 00:00:17,490
hundreds of MIT courses, visit
MIT OpenCourseware, at

7
00:00:17,490 --> 00:00:19,930
ocw.mit.edu.

8
00:00:19,930 --> 00:00:24,100
PROFESSOR JIM ERICSON:
OK, to work.

9
00:00:24,100 --> 00:00:27,730
A word of warning: fasten
your seat belts.

10
00:00:27,730 --> 00:00:29,460
Or, another way of saying it is,
I'm going to open up the

11
00:00:29,460 --> 00:00:31,610
fire hose a little bit today.

12
00:00:31,610 --> 00:00:33,780
Last lecture, you might have
thought this was a SHASS

13
00:00:33,780 --> 00:00:35,860
class, it's not like a
philosophy class, and it was

14
00:00:35,860 --> 00:00:38,620
important to set the stage for
what we're going to talk

15
00:00:38,620 --> 00:00:41,180
about, but we talked about
very high level things.

16
00:00:41,180 --> 00:00:43,960
The notion of recipes, the
notion of computation, why you

17
00:00:43,960 --> 00:00:45,700
want to do this, what you're
going to learn.

18
00:00:45,700 --> 00:00:48,000
Today we're going to dive into
the nitty-gritty, the nuts and

19
00:00:48,000 --> 00:00:51,040
bolts of the basics of
computation, and in

20
00:00:51,040 --> 00:00:53,320
particular, what I'm going to do
today is, I'm going to talk

21
00:00:53,320 --> 00:00:56,160
about operators and operands,
which we did a little bit real

22
00:00:56,160 --> 00:00:58,960
last time, in particular how
to create expressions, I'm

23
00:00:58,960 --> 00:01:02,360
going to talk about statements
as the key building blocks for

24
00:01:02,360 --> 00:01:06,060
writing code, and I'm going to
introduce simple sets of

25
00:01:06,060 --> 00:01:09,180
programs, in particular I'm
going to talk about branching,

26
00:01:09,180 --> 00:01:11,290
conditionals, and iteration.

27
00:01:11,290 --> 00:01:12,530
So, a lot to do.

28
00:01:12,530 --> 00:01:13,530
OK?

29
00:01:13,530 --> 00:01:16,070
So, let me jump straight
to it.

30
00:01:16,070 --> 00:01:18,350
At the end of last lecture, we
started introducing some of

31
00:01:18,350 --> 00:01:19,120
the pieces you want to do.

32
00:01:19,120 --> 00:01:20,450
And I want to remind
you of our goal.

33
00:01:20,450 --> 00:01:22,980
We're trying to describe
processes.

34
00:01:22,980 --> 00:01:24,700
We want to have things that
deduce new kinds of

35
00:01:24,700 --> 00:01:25,770
information.

36
00:01:25,770 --> 00:01:28,120
So we want to write programs
to do that.

37
00:01:28,120 --> 00:01:30,020
If we're going to write
programs, we need at least two

38
00:01:30,020 --> 00:01:32,570
things: we need some
representation

39
00:01:32,570 --> 00:01:34,420
for fundamental data.

40
00:01:34,420 --> 00:01:37,080
And we saw last time two
examples of that.

41
00:01:37,080 --> 00:01:39,000
And the second thing we're going
to need, is we're going

42
00:01:39,000 --> 00:01:43,230
to need a way to give
instructions to the computer

43
00:01:43,230 --> 00:01:44,390
to manipulate that data.

44
00:01:44,390 --> 00:01:47,570
We need to give it a description
of the recipe.

45
00:01:47,570 --> 00:01:52,940
In terms of primitive
data, what we saw

46
00:01:52,940 --> 00:01:56,910
were two kinds: Right?

47
00:01:56,910 --> 00:02:00,570
Numbers and strings.

48
00:02:00,570 --> 00:02:04,940
A little later on in the
lecture we're going to

49
00:02:04,940 --> 00:02:08,060
introduce a third kind of value,
but what we're going to

50
00:02:08,060 --> 00:02:11,260
see throughout the term is, no
matter how complex a data

51
00:02:11,260 --> 00:02:13,270
structure we create, and we're
going to create a variety of

52
00:02:13,270 --> 00:02:16,790
data structures, fundamentally
all of them have their basis,

53
00:02:16,790 --> 00:02:19,130
their atomic level if you like,
are going to be some

54
00:02:19,130 --> 00:02:22,290
combinations of numbers, of
strings, and the third type,

55
00:02:22,290 --> 00:02:23,700
which are booleans, which I'm
going to introduce a little

56
00:02:23,700 --> 00:02:25,670
later on in this lecture.

57
00:02:25,670 --> 00:02:27,030
And that kind of makes
sense right?

58
00:02:27,030 --> 00:02:29,210
Numbers are there to do numeric
things, strings are

59
00:02:29,210 --> 00:02:31,070
our fundamental way of
representing textual

60
00:02:31,070 --> 00:02:31,810
information.

61
00:02:31,810 --> 00:02:33,105
And so we're going to see
how to combine those

62
00:02:33,105 --> 00:02:35,810
things as we go along.

63
00:02:35,810 --> 00:02:38,800
Second thing we saw was, we saw
that associated with every

64
00:02:38,800 --> 00:02:41,480
primitive value was a type.

65
00:02:41,480 --> 00:02:42,880
And these are kind of
obvious, right?

66
00:02:42,880 --> 00:02:44,880
Strings are strings.

67
00:02:44,880 --> 00:02:47,510
For numbers, we had some
variations; we had integers,

68
00:02:47,510 --> 00:02:48,300
we had floats.

69
00:02:48,300 --> 00:02:49,910
We'll introduce a few
more as we go along.

70
00:02:49,910 --> 00:02:52,140
But those types are important,
because they tell us something

71
00:02:52,140 --> 00:02:55,560
about what we want to do when we
want to put them together.

72
00:02:55,560 --> 00:03:00,730
OK, but nonetheless, I want to
stress we have both a value,

73
00:03:00,730 --> 00:03:05,630
yeah, and a type.

74
00:03:05,630 --> 00:03:05,820
All right.

75
00:03:05,820 --> 00:03:07,210
Once we have them, we
want to start making

76
00:03:07,210 --> 00:03:08,120
combinations out of them.

77
00:03:08,120 --> 00:03:10,330
We want to put pieces
together.

78
00:03:10,330 --> 00:03:19,630
And for that, we combine
things in expressions.

79
00:03:19,630 --> 00:03:21,920
And what we saw as expressions
are formed of

80
00:03:21,920 --> 00:03:30,720
operands and operators.

81
00:03:30,720 --> 00:03:34,320
And the simple things we did
were the sort of things you'd

82
00:03:34,320 --> 00:03:36,640
expect from numerical things.

83
00:03:36,640 --> 00:03:39,300
Now I want to stress one
other nuance here.

84
00:03:39,300 --> 00:03:41,020
Which is, and we're going to
do some examples of this,

85
00:03:41,020 --> 00:03:43,590
initially we just typed in
expressions into the

86
00:03:43,590 --> 00:03:46,560
interpreter; that is, directly
into Python.

87
00:03:46,560 --> 00:03:48,740
And as I suggested last time,
the interpreter is actually a

88
00:03:48,740 --> 00:03:52,000
program inside of the machine
that is basically following

89
00:03:52,000 --> 00:03:54,346
the rules we're describing here
to deduce the value and

90
00:03:54,346 --> 00:03:55,350
print it up.

91
00:03:55,350 --> 00:03:58,040
And if we type directly into
the interpreter, it

92
00:03:58,040 --> 00:03:59,670
essentially does an
eval and a print.

93
00:03:59,670 --> 00:04:07,960
It evaluates, and it prints.

94
00:04:07,960 --> 00:04:10,730
Most of the time, we're going to
be doing expressions inside

95
00:04:10,730 --> 00:04:13,030
of some piece of code, inside
of a script, which is the

96
00:04:13,030 --> 00:04:15,150
Python word for program.

97
00:04:15,150 --> 00:04:17,700
In there, I want to make this
distinction, this nuance: the

98
00:04:17,700 --> 00:04:20,310
evaluator is still going to be
taking those expressions and

99
00:04:20,310 --> 00:04:23,040
using its rules to get a value,
but it's not going to

100
00:04:23,040 --> 00:04:24,960
print them back out.

101
00:04:24,960 --> 00:04:25,420
Why?

102
00:04:25,420 --> 00:04:27,880
Because typically, you're doing
that to use it somewhere

103
00:04:27,880 --> 00:04:28,780
else in the program.

104
00:04:28,780 --> 00:04:30,500
It's going to be stored
away in a variable.

105
00:04:30,500 --> 00:04:31,870
It's going to be stuck
in a data structure.

106
00:04:31,870 --> 00:04:34,360
It's going to be used
for a side effect.

107
00:04:34,360 --> 00:04:40,990
So, inside of code, or inside of
a script, there's no print,

108
00:04:40,990 --> 00:04:45,310
unless we make it explicit.

109
00:04:45,310 --> 00:04:47,800
And that's a little bit down in
the weeds, it's a detail,

110
00:04:47,800 --> 00:04:48,780
but one I want to stress.

111
00:04:48,780 --> 00:04:50,550
You need to, if you want
something to be printed out

112
00:04:50,550 --> 00:04:54,450
inside your code, you need to
tell the machine to do that.

113
00:04:54,450 --> 00:04:56,010
OK.

114
00:04:56,010 --> 00:04:57,460
So let's do some simple
examples.

115
00:04:57,460 --> 00:04:58,470
We've already seen somebody's.

116
00:04:58,470 --> 00:05:02,380
I just want to remind you, if I
wanted to, for example, type

117
00:05:02,380 --> 00:05:04,940
in an expression like that,
notice the syntactical form,

118
00:05:04,940 --> 00:05:07,940
it's an expression, a number,
followed by an operand,

119
00:05:07,940 --> 00:05:09,830
followed by another
expression.

120
00:05:09,830 --> 00:05:12,840
And of course I get out the
value I'd like there.

121
00:05:12,840 --> 00:05:15,810
Yes sir.

122
00:05:15,810 --> 00:05:17,650
Oh, you don't like leaning
that far to the left?

123
00:05:17,650 --> 00:05:20,230
OK, if you're a Republican I'll
be happy to shift this

124
00:05:20,230 --> 00:05:22,030
over a little bit.

125
00:05:22,030 --> 00:05:23,700
Wow, John, I got a laugh
for a political

126
00:05:23,700 --> 00:05:24,500
joke, I'm in big trouble.

127
00:05:24,500 --> 00:05:26,580
That better?

128
00:05:26,580 --> 00:05:32,740
Oh damn, all right, I'll have
to do it even more.

129
00:05:32,740 --> 00:05:35,040
OK, here we go, here we go,
you see, I'm doing it down

130
00:05:35,040 --> 00:05:37,420
here, I can't see it, does
that-- ah, I hear his sighs of

131
00:05:37,420 --> 00:05:38,570
relief, OK, good.

132
00:05:38,570 --> 00:05:39,730
There we go.

133
00:05:39,730 --> 00:05:40,140
Better.

134
00:05:40,140 --> 00:05:41,290
All right.

135
00:05:41,290 --> 00:05:42,900
One of the other things we
showed last time is that

136
00:05:42,900 --> 00:05:44,410
operators are overloaded.

137
00:05:44,410 --> 00:05:46,050
And this is where you heard
John and I disagree.

138
00:05:46,050 --> 00:05:47,720
I don't happen to like
this, but he

139
00:05:47,720 --> 00:05:49,100
thinks it's an ok thing.

140
00:05:49,100 --> 00:05:54,180
In a particular-- if we, whoa,
we don't do that, we do this--

141
00:05:54,180 --> 00:05:57,330
that is, give a combination of
a number multiplication in a

142
00:05:57,330 --> 00:06:01,460
string, this will in fact give
us back a new string with that

143
00:06:01,460 --> 00:06:03,280
many replicas, if you
like, of the string

144
00:06:03,280 --> 00:06:05,520
concatenated together.

145
00:06:05,520 --> 00:06:05,790
All right?

146
00:06:05,790 --> 00:06:08,110
And if you want to do other
things, for example, we can

147
00:06:08,110 --> 00:06:10,960
take two strings and add--
whoops, sorry-- and add them

148
00:06:10,960 --> 00:06:15,470
together, we will get
out, again, a

149
00:06:15,470 --> 00:06:17,270
concatenation of that string.

150
00:06:17,270 --> 00:06:19,040
And these will, we'll let you
work through the variations,

151
00:06:19,040 --> 00:06:21,690
but these are the simple
expressions we can use.

152
00:06:21,690 --> 00:06:25,440
Now, sometimes things get
a little interesting.

153
00:06:25,440 --> 00:06:27,860
All right?

154
00:06:27,860 --> 00:06:33,250
What's the value of
that expression?

155
00:06:33,250 --> 00:06:35,360
What do you think should happen
if I evaluate that

156
00:06:35,360 --> 00:06:38,350
expression?

157
00:06:38,350 --> 00:06:38,470
Somebody with a hand up,
so I can see it.

158
00:06:38,470 --> 00:06:39,120
What's going to happen?

159
00:06:39,120 --> 00:06:41,390
STUDENT: [UNINTELLIGIBLE]

160
00:06:41,390 --> 00:06:43,350
PROFESSOR JIM ERICSON:
An error?

161
00:06:43,350 --> 00:06:43,830
Why?

162
00:06:43,830 --> 00:06:48,210
STUDENT: [UNINTELLIGIBLE]

163
00:06:48,210 --> 00:06:50,538
PROFESSOR JIM ERICSON: Great.

164
00:06:50,538 --> 00:06:50,686
OK.

165
00:06:50,686 --> 00:06:51,021
That means, let's check it.

166
00:06:51,021 --> 00:06:52,550
It certainly is.

167
00:06:52,550 --> 00:06:53,670
We bribe people.

168
00:06:53,670 --> 00:06:57,540
So I, ah, by the way, John's a
Yankees fan, he throws like

169
00:06:57,540 --> 00:07:00,430
Johnny Damon, I'm a Red Sox fan,
so we'll see if I, how

170
00:07:00,430 --> 00:07:00,770
about that?

171
00:07:00,770 --> 00:07:03,530
And I almost hit John along
the way, great.

172
00:07:03,530 --> 00:07:05,350
My third right, exactly,
what can I say?

173
00:07:05,350 --> 00:07:07,620
All right, so we're into bribing
you as we go along

174
00:07:07,620 --> 00:07:08,730
here, and all right?

175
00:07:08,730 --> 00:07:11,340
You'll be badly overweight
by the end of the term.

176
00:07:11,340 --> 00:07:13,670
Right, it's a syntactic error,
because it doesn't know how to

177
00:07:13,670 --> 00:07:14,390
deal with this.

178
00:07:14,390 --> 00:07:16,500
But there's an important thing
going on here, if I in fact

179
00:07:16,500 --> 00:07:19,610
wanted to combine those into a
string, I should have told the

180
00:07:19,610 --> 00:07:23,690
machine to do that, and I can do
that, by explicitly saying,

181
00:07:23,690 --> 00:07:27,700
take that, which is a number,
and convert it into a string,

182
00:07:27,700 --> 00:07:29,680
and then-- bleah, I keep
doing that-- then

183
00:07:29,680 --> 00:07:33,650
add it to that string.

184
00:07:33,650 --> 00:07:35,960
OK, so there's an important
point here.

185
00:07:35,960 --> 00:07:44,810
We've got what's called
type conversion.

186
00:07:44,810 --> 00:07:48,800
That is, if I want to combine
two things together in a

187
00:07:48,800 --> 00:07:52,200
particular way, I need to make
sure that I give it the kind

188
00:07:52,200 --> 00:07:53,740
of operand it expects.

189
00:07:53,740 --> 00:07:57,800
So STR, which I just typed up
there, takes in parens, some

190
00:07:57,800 --> 00:08:01,040
input, and it converts it into
a string, so that now I can

191
00:08:01,040 --> 00:08:02,970
use that where I was
expecting a string.

192
00:08:02,970 --> 00:08:03,350
John.

193
00:08:03,350 --> 00:08:07,656
PROFESSOR JOHN GUTTAG: You've
got a static semantic error in

194
00:08:07,656 --> 00:08:07,710
your syntax.

195
00:08:07,710 --> 00:08:08,694
PROFESSOR JIM ERICSON:
Thank you.

196
00:08:08,694 --> 00:08:10,220
And I was going to come to that
in a second, but thank

197
00:08:10,220 --> 00:08:11,260
you, John, for pointing it out.

198
00:08:11,260 --> 00:08:12,550
All right.

199
00:08:12,550 --> 00:08:15,120
Why is it a static
semantic error?

200
00:08:15,120 --> 00:08:18,670
The syntax is OK in the sense
of, it is an operand, an

201
00:08:18,670 --> 00:08:23,380
operator, an operand, so
syntactically it's OK.

202
00:08:23,380 --> 00:08:26,000
The semantics was what caused
the problem, because the

203
00:08:26,000 --> 00:08:28,670
operator was expecting
a particular kind

204
00:08:28,670 --> 00:08:30,380
of structure there.

205
00:08:30,380 --> 00:08:32,020
There's a second thing going
on here that I want to

206
00:08:32,020 --> 00:08:36,480
highlight, because it's
really important.

207
00:08:36,480 --> 00:08:37,420
Yes indeed.

208
00:08:37,420 --> 00:08:38,970
OK, there we go.

209
00:08:38,970 --> 00:08:41,450
The second thing I want to
highlight is, that what's

210
00:08:41,450 --> 00:08:48,130
going on, is that Python is
doing some type checking.

211
00:08:48,130 --> 00:08:51,580
It caught the error, because
it checked the types of the

212
00:08:51,580 --> 00:08:54,050
operands before it applied
things, and it says,

213
00:08:54,050 --> 00:08:55,640
I'm going to stop.

214
00:08:55,640 --> 00:08:57,860
Now, you might have said, gee,
why didn't it just assume that

215
00:08:57,860 --> 00:09:00,030
I wanted to in fact treat these
as strings, and combine

216
00:09:00,030 --> 00:09:01,130
them together?

217
00:09:01,130 --> 00:09:03,540
Sounds like a reasonable
thing to do.

218
00:09:03,540 --> 00:09:05,300
But it's a dangerous thing.

219
00:09:05,300 --> 00:09:08,230
Because in doing that, Python
would then have a value that

220
00:09:08,230 --> 00:09:10,280
it could pass on into some other
part of a computation,

221
00:09:10,280 --> 00:09:13,820
and if it wasn't what I wanted,
I might be a long ways

222
00:09:13,820 --> 00:09:16,910
downstream in the computation
before I actually hit some

223
00:09:16,910 --> 00:09:18,960
result that makes no sense.

224
00:09:18,960 --> 00:09:21,330
And tracing back where it came
from can be really hard.

225
00:09:21,330 --> 00:09:23,810
So I actually want to have
type checking as much

226
00:09:23,810 --> 00:09:26,340
as I can early on.

227
00:09:26,340 --> 00:09:28,380
And in fact, under type
checking, different languages

228
00:09:28,380 --> 00:09:36,740
sometimes fall on a spectrum
from weak to strong typing.

229
00:09:36,740 --> 00:09:39,830
Which basically says, how much
type checking do they do?

230
00:09:39,830 --> 00:09:42,370
Now, you're going to hear John
and I go back and forth a lot,

231
00:09:42,370 --> 00:09:44,470
as I said I'm an old time-- well
I'm certainly old time,

232
00:09:44,470 --> 00:09:46,770
but I'm also an old time
Lisp programmer.

233
00:09:46,770 --> 00:09:49,320
I love Lisp, but Lisp is
certainly in the category of a

234
00:09:49,320 --> 00:09:50,680
very weakly typed language.

235
00:09:50,680 --> 00:09:53,830
It does not check the types
of its arguments at all.

236
00:09:53,830 --> 00:09:55,960
Python is, I wouldn't say
completely strong, but it's

237
00:09:55,960 --> 00:09:58,060
much closer to the strong
end of the spectrum.

238
00:09:58,060 --> 00:10:00,900
It's going to do a lot of type
checking for you before it

239
00:10:00,900 --> 00:10:03,400
actually passes things back.

240
00:10:03,400 --> 00:10:06,080
Nonetheless, I'm also going to
argue that it's probably not

241
00:10:06,080 --> 00:10:08,570
as strongly typed as
we might like.

242
00:10:08,570 --> 00:10:13,440
So, for example, there's
an expression.

243
00:10:13,440 --> 00:10:15,455
Now, less than is just, if you
haven't used it before, it's

244
00:10:15,455 --> 00:10:17,380
just the operator you'd expect,
it's comparing two

245
00:10:17,380 --> 00:10:19,200
things and it's going to return
either true or false

246
00:10:19,200 --> 00:10:21,210
depending on whether the first
argument is less than the

247
00:10:21,210 --> 00:10:23,270
second argument.

248
00:10:23,270 --> 00:10:24,690
What's going to happen here?

249
00:10:24,690 --> 00:10:28,360
Again, I need a hand so I can
know where to throw candy.

250
00:10:28,360 --> 00:10:29,420
I've also got on my
reading glasses

251
00:10:29,420 --> 00:10:31,600
on, I can't see anything.

252
00:10:31,600 --> 00:10:33,140
Anybody.

253
00:10:33,140 --> 00:10:36,660
TAs don't count, they
get their own candy.

254
00:10:36,660 --> 00:10:37,300
When it, yep.

255
00:10:37,300 --> 00:10:39,260
STUDENT: [INAUDIBLE]

256
00:10:39,260 --> 00:10:40,020
PROFESSOR JIM ERICSON:
Good question.

257
00:10:40,020 --> 00:10:41,000
Sounds like a reasonable
guess, right?

258
00:10:41,000 --> 00:10:44,030
How in the world am I going to
compare a string to a number?

259
00:10:44,030 --> 00:10:46,990
So, see how good my aim
is, ah, not bad.

260
00:10:46,990 --> 00:10:47,880
All right.

261
00:10:47,880 --> 00:10:51,010
A good quest-- sorry, a
good thought, but in

262
00:10:51,010 --> 00:10:53,820
fact, son of a gun.

263
00:10:53,820 --> 00:10:58,240
Or as my younger son would
say, fudge knuckle.

264
00:10:58,240 --> 00:10:58,890
Yeah.

265
00:10:58,890 --> 00:10:59,210
All right?

266
00:10:59,210 --> 00:11:01,290
So, what in the world's
going on here?

267
00:11:01,290 --> 00:11:02,220
This is a place--

268
00:11:02,220 --> 00:11:04,150
I don't know about you, John,
I think this is actually

269
00:11:04,150 --> 00:11:07,900
really not good, because right,
what this is doing is,

270
00:11:07,900 --> 00:11:12,280
it's allowing-- sorry, let me
back up and say it-- it's got

271
00:11:12,280 --> 00:11:14,800
an overload on the less-than
that allows you to compare

272
00:11:14,800 --> 00:11:18,360
basically the lexicographic
ordering, or this sequence of

273
00:11:18,360 --> 00:11:22,680
ordering of symbols, including
numbers inside of the machine.

274
00:11:22,680 --> 00:11:24,550
And this, in my mind, should
have been an error.

275
00:11:24,550 --> 00:11:26,750
Why in the world would you
want to compare that?

276
00:11:26,750 --> 00:11:29,510
Just to give you an example of
that, for instance, I can do

277
00:11:29,510 --> 00:11:35,360
the following: all right, the
number four is less than the

278
00:11:35,360 --> 00:11:42,370
string three, whereas the string
four, oops, is not less

279
00:11:42,370 --> 00:11:43,740
than the string three.

280
00:11:43,740 --> 00:11:46,210
And this is a place where it's
comparing strings and numbers

281
00:11:46,210 --> 00:11:47,750
in a strange way.

282
00:11:47,750 --> 00:11:48,920
So why am I showing you this?

283
00:11:48,920 --> 00:11:51,620
Partly to show you that it's
kind of weird, but also to

284
00:11:51,620 --> 00:11:56,210
tell you that one of the things
you want to do is

285
00:11:56,210 --> 00:12:00,510
exercise what I'm going to call
some type discipline.

286
00:12:00,510 --> 00:12:05,100
Meaning, when you write code,
you want to get into the habit

287
00:12:05,100 --> 00:12:08,250
of A, checking out operators or
procedures to see what they

288
00:12:08,250 --> 00:12:10,320
do under different
circumstances, either check

289
00:12:10,320 --> 00:12:13,100
them out or read the
specifications of it, and two,

290
00:12:13,100 --> 00:12:15,740
when you write your own code,
you want to be disciplined

291
00:12:15,740 --> 00:12:18,280
about what types of arguments
or operands

292
00:12:18,280 --> 00:12:20,620
you apply to operators.

293
00:12:20,620 --> 00:12:22,540
Because this is something that
could certainly have screwed

294
00:12:22,540 --> 00:12:25,370
you up if you didn't realize
it did it, and you need to

295
00:12:25,370 --> 00:12:26,550
have that discipline
to make sure it's

296
00:12:26,550 --> 00:12:29,160
doing the right thing.

297
00:12:29,160 --> 00:12:30,570
OK.

298
00:12:30,570 --> 00:12:33,420
One of the other things you're
going to see is that some of

299
00:12:33,420 --> 00:12:36,080
the operators have
odd meanings.

300
00:12:36,080 --> 00:12:37,290
And again, I think we looked--

301
00:12:37,290 --> 00:12:37,770
Yup?

302
00:12:37,770 --> 00:12:40,130
STUDENT: So, the string A is
less than three, is false

303
00:12:40,130 --> 00:12:40,340
because they're comparing
like ASCII values?

304
00:12:40,340 --> 00:12:45,360
PROFESSOR JIM ERICSON: Yes.

305
00:12:45,360 --> 00:12:46,340
I mean, I'm sorry.

306
00:12:46,340 --> 00:12:47,550
The answer is, I don't
know if it's ASCII.

307
00:12:47,550 --> 00:12:48,870
John, do you know, are
they doing ASCII

308
00:12:48,870 --> 00:12:49,830
encoding inside of here?

309
00:12:49,830 --> 00:12:51,540
I'm assuming so.

310
00:12:51,540 --> 00:12:51,780
Right.

311
00:12:51,780 --> 00:12:53,320
So, in case you didn't
understand what the the

312
00:12:53,320 --> 00:12:57,910
question was, basically every
symbol gets translated into a

313
00:12:57,910 --> 00:13:00,710
particular encoding, a string
of bit, if you like, inside

314
00:13:00,710 --> 00:13:02,450
the machine, there's a
particular one called ASCII,

315
00:13:02,450 --> 00:13:05,400
which is, if you like, an
ordering of that, and that's

316
00:13:05,400 --> 00:13:07,200
what the machine's actually
comparing inside of here,

317
00:13:07,200 --> 00:13:09,830
which is why in under ASCII
encoding the numbers are going

318
00:13:09,830 --> 00:13:12,530
to appear after the characters,
and you get the

319
00:13:12,530 --> 00:13:14,930
strange kind of thing going on.

320
00:13:14,930 --> 00:13:15,160
All right.

321
00:13:15,160 --> 00:13:16,960
I want a couple of other things,
just to quickly remind

322
00:13:16,960 --> 00:13:19,020
you, and one of them is,
remember, the operators do

323
00:13:19,020 --> 00:13:21,490
look at the types, so division,
for example nine

324
00:13:21,490 --> 00:13:25,290
divided by five is one, because
this is integer

325
00:13:25,290 --> 00:13:27,930
division, that is, it's the
largest number of integer

326
00:13:27,930 --> 00:13:30,680
multiples of five to go into
nine, and there would be a

327
00:13:30,680 --> 00:13:36,580
remainder associated with it,
which is in fact four.

328
00:13:36,580 --> 00:13:37,810
And again, you've got
to be careful about

329
00:13:37,810 --> 00:13:40,010
how you use the operators.

330
00:13:40,010 --> 00:13:41,890
Right, having done that, we
can certainly get to more

331
00:13:41,890 --> 00:13:46,060
complicated things, so for
example, suppose I look at

332
00:13:46,060 --> 00:13:47,660
that expression.

333
00:13:47,660 --> 00:13:50,570
Three plus four times five.

334
00:13:50,570 --> 00:13:51,680
All right.

335
00:13:51,680 --> 00:13:52,180
Now.

336
00:13:52,180 --> 00:13:55,420
There are two possible
values here, I think.

337
00:13:55,420 --> 00:13:57,770
One is 23, the other's 35.

338
00:13:57,770 --> 00:14:03,370
Because this could be three plus
four, times five, or it

339
00:14:03,370 --> 00:14:07,150
could be three, plus
four times five.

340
00:14:07,150 --> 00:14:08,990
And of course, you know, when
you look at code it doesn't

341
00:14:08,990 --> 00:14:09,780
pause in between them.

342
00:14:09,780 --> 00:14:10,360
But what I do?

343
00:14:10,360 --> 00:14:12,620
I just separated, do I do the
addition first or do the

344
00:14:12,620 --> 00:14:14,520
multiplication first?

345
00:14:14,520 --> 00:14:15,800
Anybody know what happens
In this case?

346
00:14:15,800 --> 00:14:17,210
Yeah, way up, oh God I'm going
to have a hell of time

347
00:14:17,210 --> 00:14:18,320
throwing up there, way
up at the back.

348
00:14:18,320 --> 00:14:25,604
STUDENT: Standard order of
operations, I guess take the

349
00:14:25,604 --> 00:14:26,040
multiplication first,
and add the three.

350
00:14:26,040 --> 00:14:26,361
PROFESSOR JIM ERICSON: Right.

351
00:14:26,361 --> 00:14:27,800
I'm going to try, if I don't
make it, you know, just get

352
00:14:27,800 --> 00:14:29,220
somebody to pass back, whoa!

353
00:14:29,220 --> 00:14:30,214
I just hit somebody
in the head.

354
00:14:30,214 --> 00:14:30,340
Thank you.

355
00:14:30,340 --> 00:14:32,220
Please pass it back
to that guy.

356
00:14:32,220 --> 00:14:34,410
If you want candy, sit much
closer down, and that way we

357
00:14:34,410 --> 00:14:36,310
can film you as well
as we go along.

358
00:14:36,310 --> 00:14:36,590
Right.

359
00:14:36,590 --> 00:14:39,000
So the point is, there is
something here called operator

360
00:14:39,000 --> 00:14:45,530
precedence, which is what
the gentleman said.

361
00:14:45,530 --> 00:14:48,150
I'm not going to say much more
about it, but basically what

362
00:14:48,150 --> 00:14:52,110
it says is, with all other
things being equal, things

363
00:14:52,110 --> 00:14:56,750
like exponentiation are done
before you do multiplication

364
00:14:56,750 --> 00:15:00,100
or division, which are done
before you do things like

365
00:15:00,100 --> 00:15:02,320
addition and subtraction.

366
00:15:02,320 --> 00:15:04,485
And so, in fact, if I wanted
the other version of it, in

367
00:15:04,485 --> 00:15:06,730
fact, if I do this right, it's
going to give me 23 because it

368
00:15:06,730 --> 00:15:09,370
does the multiplication first,
if I wanted the other version

369
00:15:09,370 --> 00:15:13,160
of it, I need to tell it that,
by using, excuse me,

370
00:15:13,160 --> 00:15:14,970
parentheses.

371
00:15:14,970 --> 00:15:16,720
And in general, what I
would say is, when

372
00:15:16,720 --> 00:15:26,410
in doubt, use parens.

373
00:15:26,410 --> 00:15:29,010
OK.

374
00:15:29,010 --> 00:15:32,830
Now, that just gives
us expressions.

375
00:15:32,830 --> 00:15:35,110
We can start having complex
expressions, you can imagine

376
00:15:35,110 --> 00:15:36,920
we can have things are lots of
parens, and all sorts of

377
00:15:36,920 --> 00:15:37,340
things in it.

378
00:15:37,340 --> 00:15:38,010
Yes, question.

379
00:15:38,010 --> 00:15:46,102
STUDENT: What does it mean, the
operator used, when you

380
00:15:46,102 --> 00:15:46,260
were calculating the remainder
between nine and five?

381
00:15:46,260 --> 00:15:46,540
PROFESSOR JIM ERICSON: It's
the percent sign.

382
00:15:46,540 --> 00:15:47,230
If you can't read it, I guess
I'm going to have to blow that

383
00:15:47,230 --> 00:15:47,820
font up, aren't I,
next time around.

384
00:15:47,820 --> 00:15:49,354
Yeah, it's a percent, so
this percent sign will

385
00:15:49,354 --> 00:15:52,480
give you the remainder.

386
00:15:52,480 --> 00:15:53,540
OK.

387
00:15:53,540 --> 00:15:55,670
Second thing I need to do,
though, is I need to, when I

388
00:15:55,670 --> 00:15:57,560
get those values, I want
to hang on to them.

389
00:15:57,560 --> 00:15:59,710
I'd like to give them a name,
so I can refer to them in

390
00:15:59,710 --> 00:16:00,900
other places.

391
00:16:00,900 --> 00:16:05,012
And so we saw that as well, the
last piece we had here is

392
00:16:05,012 --> 00:16:12,880
the ability to create variables,
which have their

393
00:16:12,880 --> 00:16:20,100
own values, and that's done
using an assignment statement.

394
00:16:20,100 --> 00:16:24,380
So in particular, that is
an assignment statement.

395
00:16:24,380 --> 00:16:29,060
It says, take the name x and
create a binding for that name

396
00:16:29,060 --> 00:16:31,180
to the value of the
sub-expression and in fact to

397
00:16:31,180 --> 00:16:35,300
do this, to stress a point,
let's do that.

398
00:16:35,300 --> 00:16:39,130
It's not just a number,
it's any expression.

399
00:16:39,130 --> 00:16:41,790
What Python will do, is it will
evaluate that expression

400
00:16:41,790 --> 00:16:43,570
using the kinds of rules we
talked about, and then it

401
00:16:43,570 --> 00:16:45,690
creates a binding for
x to that value.

402
00:16:45,690 --> 00:16:47,340
And I want to stress this, we're
going to come back to it

403
00:16:47,340 --> 00:16:50,060
later on in the term, so the
way I'd like you to think

404
00:16:50,060 --> 00:16:53,330
about it for now, is that
somewhere in the machine,

405
00:16:53,330 --> 00:16:57,080
there's a big space that
contains all possible values.

406
00:16:57,080 --> 00:16:57,250
Right.

407
00:16:57,250 --> 00:16:59,420
It's a slight lie, it doesn't
have all possible values, but

408
00:16:59,420 --> 00:17:00,050
you get the idea.

409
00:17:00,050 --> 00:17:01,640
It has, if you like,
intellectually,

410
00:17:01,640 --> 00:17:03,100
all possible values.

411
00:17:03,100 --> 00:17:07,310
And when I create a binding, I'm
taking a variable name, in

412
00:17:07,310 --> 00:17:11,140
this case x, stored somewhere in
a table, and I'm creating a

413
00:17:11,140 --> 00:17:20,410
link or a pointer from that
name to that value.

414
00:17:20,410 --> 00:17:21,740
This is a nuance.

415
00:17:21,740 --> 00:17:23,480
It's going to make a lot more
sense later on when we

416
00:17:23,480 --> 00:17:26,040
introduce mutation into our
language, but I want you to

417
00:17:26,040 --> 00:17:26,870
start thinking of it that way.

418
00:17:26,870 --> 00:17:29,660
Don't think of it as a specific
box into which we're

419
00:17:29,660 --> 00:17:32,920
putting things; think of it
as a link to a value.

420
00:17:32,920 --> 00:17:37,540
I could have, for example,
another assignment statement,

421
00:17:37,540 --> 00:17:45,630
and that creates a binding from
y into that same value,

422
00:17:45,630 --> 00:17:47,710
and one of the things as a
conservist I can do is, I

423
00:17:47,710 --> 00:17:53,180
could have a statement like,
let z be bound to

424
00:17:53,180 --> 00:17:54,340
the value of x.

425
00:17:54,340 --> 00:17:55,700
And I said it deliberately
that way.

426
00:17:55,700 --> 00:17:58,715
That statement says, get the
value of x, which is this

427
00:17:58,715 --> 00:18:05,250
link, and give z a pointer
to the same place.

428
00:18:05,250 --> 00:18:08,770
To the value, not to x.

429
00:18:08,770 --> 00:18:10,470
OK, and we'll just plant that
idea, we're going to come back

430
00:18:10,470 --> 00:18:13,980
to later on, as we carry on.

431
00:18:13,980 --> 00:18:14,390
OK.

432
00:18:14,390 --> 00:18:17,770
So if we have variables, one
of the questions we can ask

433
00:18:17,770 --> 00:18:25,500
is, what's the type
of the variable.

434
00:18:25,500 --> 00:18:28,830
And the answer is, it inherits
it from its value.

435
00:18:28,830 --> 00:18:30,550
OK.

436
00:18:30,550 --> 00:18:35,810
Yes.

437
00:18:35,810 --> 00:18:39,380
So if somewhere in my code, I
have that statement, that

438
00:18:39,380 --> 00:18:41,520
assignment statement,
x now is a variable

439
00:18:41,520 --> 00:18:44,670
whose value is an integer.

440
00:18:44,670 --> 00:18:47,980
Unfortunately, at least in
my mind, in Python, these

441
00:18:47,980 --> 00:18:51,550
variable bindings are
dynamic, or the

442
00:18:51,550 --> 00:18:55,590
type, rather, is dynamic.

443
00:18:55,590 --> 00:19:00,990
Meaning, it changes depending on
what the current value is.

444
00:19:00,990 --> 00:19:03,330
Or said a different way, if
somewhere later on in the

445
00:19:03,330 --> 00:19:10,110
program I do this, x
now has changed its

446
00:19:10,110 --> 00:19:14,270
type from INT to string.

447
00:19:14,270 --> 00:19:16,130
Now why should you care?

448
00:19:16,130 --> 00:19:21,110
OK, my view is, I
don't like it.

449
00:19:21,110 --> 00:19:24,330
Especially in the presence
of operator overload.

450
00:19:24,330 --> 00:19:26,450
Because I might have written
some code in which I'm

451
00:19:26,450 --> 00:19:28,180
expecting that particular
variable to

452
00:19:28,180 --> 00:19:29,040
have an integer value.

453
00:19:29,040 --> 00:19:32,640
If somewhere later on in the
code it shifts to string, I

454
00:19:32,640 --> 00:19:35,650
might not be manipulating that
and getting actual values out,

455
00:19:35,650 --> 00:19:37,850
but not what I wanted, and it's
going to be really hard

456
00:19:37,850 --> 00:19:39,450
for me to chase it back.

457
00:19:39,450 --> 00:19:41,540
So one of the things I would
like to suggest is that you

458
00:19:41,540 --> 00:19:46,330
develop some good style here,
and in particular, don't

459
00:19:46,330 --> 00:19:52,360
change types arbitrarily.

460
00:19:52,360 --> 00:19:59,380
I can't spell today.

461
00:19:59,380 --> 00:20:01,570
Meaning, sometimes you need
to do this, but in general

462
00:20:01,570 --> 00:20:03,300
there's-- at least in my view
and I don't, John, would you

463
00:20:03,300 --> 00:20:04,350
agree?-- you just don't
want to do this.

464
00:20:04,350 --> 00:20:05,640
You don't want to make
those changes.

465
00:20:05,640 --> 00:20:08,920
It just leads to trouble
down the road.

466
00:20:08,920 --> 00:20:10,530
OK.

467
00:20:10,530 --> 00:20:12,173
Now, last thing about variables,
and then we're

468
00:20:12,173 --> 00:20:13,230
going to start pushing
on this, is

469
00:20:13,230 --> 00:20:14,820
where can you use them?

470
00:20:14,820 --> 00:20:19,610
And the answer is, you can use
a variable anywhere you can

471
00:20:19,610 --> 00:20:20,300
use the value.

472
00:20:20,300 --> 00:20:32,630
So, any place it's legal
to use the value.

473
00:20:32,630 --> 00:20:35,750
OK.

474
00:20:35,750 --> 00:20:36,900
Now.

475
00:20:36,900 --> 00:20:39,420
This is just sort of bringing us
back up to speed and adding

476
00:20:39,420 --> 00:20:40,240
a few more details in.

477
00:20:40,240 --> 00:20:42,290
What we really want to
do now though is

478
00:20:42,290 --> 00:20:44,900
start using this stuff.

479
00:20:44,900 --> 00:20:46,880
So, operands.

480
00:20:46,880 --> 00:20:49,890
Let us take expressions, get
values out, we can store them

481
00:20:49,890 --> 00:20:52,450
away in places, but ultimately
we want to do something with

482
00:20:52,450 --> 00:20:54,390
them, so we need to now start
talking about what are the

483
00:20:54,390 --> 00:20:56,740
things we can do inside of
Python, or any programming

484
00:20:56,740 --> 00:20:58,640
language, to manipulate them.

485
00:20:58,640 --> 00:21:08,960
And for that, we're going
to have statements.

486
00:21:08,960 --> 00:21:13,610
Statements are basically, if
you want to think about it,

487
00:21:13,610 --> 00:21:15,980
legal, and I was about to use
the word expression except

488
00:21:15,980 --> 00:21:24,530
I've misused that elsewhere, so
legal commands that Python

489
00:21:24,530 --> 00:21:30,040
can interpret.

490
00:21:30,040 --> 00:21:32,520
You've already seen
a couple of them.

491
00:21:32,520 --> 00:21:39,650
Print, assignment, certainly
two obvious statements,

492
00:21:39,650 --> 00:21:41,000
they're commands to
do something.

493
00:21:41,000 --> 00:21:43,660
Assignment is binding a name
to a value, print is saying

494
00:21:43,660 --> 00:21:45,160
put it back out in the screen.

495
00:21:45,160 --> 00:21:47,240
Obviously if you have print as
a way of putting things out,

496
00:21:47,240 --> 00:21:48,940
we expect to have ways of
getting input in, we're going

497
00:21:48,940 --> 00:21:50,630
to see an example that
in the second.

498
00:21:50,630 --> 00:21:52,340
And as we go through the next
few lectures, we're going to

499
00:21:52,340 --> 00:21:54,190
add in more and more of
these statements.

500
00:21:54,190 --> 00:21:56,830
But let's look at what we
could do with this, OK?

501
00:21:56,830 --> 00:21:59,240
And to do this, I'm going to
use some code that I've

502
00:21:59,240 --> 00:22:00,450
already typed in.

503
00:22:00,450 --> 00:22:01,850
So I'm hoping you can
read that, and it's

504
00:22:01,850 --> 00:22:03,210
also in your handout.

505
00:22:03,210 --> 00:22:06,780
This is a little file I created,
all right, and I'm

506
00:22:06,780 --> 00:22:09,850
going to start with a sequence
of these things and walk them

507
00:22:09,850 --> 00:22:12,440
along, again I invite you to put
comments on that handout

508
00:22:12,440 --> 00:22:14,830
so that you can follow what
we're going to do.

509
00:22:14,830 --> 00:22:15,450
All right?

510
00:22:15,450 --> 00:22:16,730
So let's look at the
first part of this.

511
00:22:16,730 --> 00:22:19,520
Right now, this is
just a text file.

512
00:22:19,520 --> 00:22:19,700
OK.

513
00:22:19,700 --> 00:22:21,790
And I've highlighted in blue up
there one of the pieces I'm

514
00:22:21,790 --> 00:22:22,870
going to start with.

515
00:22:22,870 --> 00:22:23,380
And what do I have?

516
00:22:23,380 --> 00:22:25,320
I have a sequence of commands;
I've got an assignment

517
00:22:25,320 --> 00:22:27,710
statement, I've got another
assignment statement, I've got

518
00:22:27,710 --> 00:22:29,900
a print statement, I've got an
input statement, which we'll

519
00:22:29,900 --> 00:22:31,940
come back to in a second.

520
00:22:31,940 --> 00:22:34,350
And I want to basically try
and use these things to do

521
00:22:34,350 --> 00:22:35,660
something with them.

522
00:22:35,660 --> 00:22:38,270
Second thing I want to note is,
the little hash mark or

523
00:22:38,270 --> 00:22:41,600
the pound sign, that's
identifying a comment.

524
00:22:41,600 --> 00:22:42,390
So what's a comment?

525
00:22:42,390 --> 00:22:46,060
It's words to you, or to the
reader of the code, that are

526
00:22:46,060 --> 00:22:47,980
telling you what's going
on inside of this code.

527
00:22:47,980 --> 00:22:49,690
OK?

528
00:22:49,690 --> 00:22:54,770
Now, these comments, frankly,
are brain-damaged, or

529
00:22:54,770 --> 00:22:57,330
computationally challenged
if you prefer.

530
00:22:57,330 --> 00:23:00,590
Meaning, why in the world do I
have to tell the reader that

531
00:23:00,590 --> 00:23:02,480
I'm binding x to the
value three?

532
00:23:02,480 --> 00:23:02,770
All right?

533
00:23:02,770 --> 00:23:04,870
I'm putting them in there
to make a point.

534
00:23:04,870 --> 00:23:08,510
In general, good programming
style says you put in comments

535
00:23:08,510 --> 00:23:11,880
that are going to be valuable
in helping you as a reader

536
00:23:11,880 --> 00:23:14,780
understand what's going
on inside of the code.

537
00:23:14,780 --> 00:23:16,430
It could be, what's the
intuition behind

538
00:23:16,430 --> 00:23:17,080
this piece of code.

539
00:23:17,080 --> 00:23:19,580
It could be, preconditions
I want to have on input.

540
00:23:19,580 --> 00:23:22,420
It could be, explanations of
specific things you're doing.

541
00:23:22,420 --> 00:23:25,320
But you need to have those
comments there.

542
00:23:25,320 --> 00:23:27,540
Now, this becomes a little bit
of one of those motherhood and

543
00:23:27,540 --> 00:23:28,800
apple pie kinds of lectures.

544
00:23:28,800 --> 00:23:30,370
You know, your mother always
told you to eat brussels

545
00:23:30,370 --> 00:23:32,270
sprouts because it
was good for you.

546
00:23:32,270 --> 00:23:34,050
Well this is a brussels sprouts
comment. everybody

547
00:23:34,050 --> 00:23:35,480
goes yeah, yeah, yeah,
comments, of course.

548
00:23:35,480 --> 00:23:36,580
Of course we're going
to do comments.

549
00:23:36,580 --> 00:23:38,250
And they never do.

550
00:23:38,250 --> 00:23:40,730
So my challenge to you, and I
know Professor Guttag can do

551
00:23:40,730 --> 00:23:44,800
this, my challenge to you is, a
year from now, come back and

552
00:23:44,800 --> 00:23:46,650
look at code you wrote here.

553
00:23:46,650 --> 00:23:50,860
Can you still understand what it
was you were trying to do?

554
00:23:50,860 --> 00:23:52,170
I don't know, John, if
you'd agree, right?

555
00:23:52,170 --> 00:23:54,210
If you can read the code a
year later, even code you

556
00:23:54,210 --> 00:23:56,630
wrote yourself, it's a good
sign that you put good

557
00:23:56,630 --> 00:23:59,340
comments in, right?

558
00:23:59,340 --> 00:24:01,360
Second good piece
of style here is

559
00:24:01,360 --> 00:24:03,530
choice of variable names.

560
00:24:03,530 --> 00:24:05,200
These are lousy.

561
00:24:05,200 --> 00:24:06,040
Deliberately.

562
00:24:06,040 --> 00:24:06,840
OK?

563
00:24:06,840 --> 00:24:09,260
I'm just using simple things
like x and y and z because I

564
00:24:09,260 --> 00:24:10,600
want to make it, just
get through the

565
00:24:10,600 --> 00:24:11,340
lecture if you like.

566
00:24:11,340 --> 00:24:14,310
But in general, the choice of
variable name is a great way

567
00:24:14,310 --> 00:24:15,860
of commenting your code.

568
00:24:15,860 --> 00:24:19,000
Use variable names
that make sense.

569
00:24:19,000 --> 00:24:21,250
That little problem set
zero that you did.

570
00:24:21,250 --> 00:24:22,340
You read in a couple
of values, you

571
00:24:22,340 --> 00:24:23,960
probably stored them away.

572
00:24:23,960 --> 00:24:27,340
My bet is, you used simple
names like x and y.

573
00:24:27,340 --> 00:24:29,790
A much better name would have
been firstname, lastname, as

574
00:24:29,790 --> 00:24:31,650
the name of the variable to tell
you what you were trying

575
00:24:31,650 --> 00:24:33,540
to capture there.

576
00:24:33,540 --> 00:24:34,390
OK.

577
00:24:34,390 --> 00:24:38,300
The other piece I want to say
about variable names is, once

578
00:24:38,300 --> 00:24:41,980
I have that choice of variable
name, I can use it, but in

579
00:24:41,980 --> 00:24:44,260
fact there are a few things that
I can't use in terms of

580
00:24:44,260 --> 00:24:45,030
variable names.

581
00:24:45,030 --> 00:24:58,100
So, these are an important way
of documenting, but there're

582
00:24:58,100 --> 00:24:59,040
some things excluded.

583
00:24:59,040 --> 00:25:04,210
And in particular, there are
some key words that Python is

584
00:25:04,210 --> 00:25:07,270
going to use that have
to be excluded.

585
00:25:07,270 --> 00:25:09,180
Let me highlight that.

586
00:25:09,180 --> 00:25:10,860
As I said, right now that's
just text file.

587
00:25:10,860 --> 00:25:15,560
I'm going to save this away--
yeah, not that way, I'm going

588
00:25:15,560 --> 00:25:22,700
to save this away-- with the
subscript, or the suffix

589
00:25:22,700 --> 00:25:25,480
rather, py to make
it a Python file.

590
00:25:25,480 --> 00:25:28,600
Yeah, and I know it's already
there but I'm going to do it,

591
00:25:28,600 --> 00:25:30,920
and I get some wonderful
colors.

592
00:25:30,920 --> 00:25:33,130
But these are important, OK?

593
00:25:33,130 --> 00:25:34,640
So notice what I have
up there now.

594
00:25:34,640 --> 00:25:35,830
Comments appear in red.

595
00:25:35,830 --> 00:25:37,310
I can see those.

596
00:25:37,310 --> 00:25:39,580
There's a keyword, which I'm
going to highlight right up

597
00:25:39,580 --> 00:25:41,850
here, print, which is in,
I don't know what

598
00:25:41,850 --> 00:25:44,550
that color is, orange?

599
00:25:44,550 --> 00:25:48,330
There's a function in purple,
there's a string in green, and

600
00:25:48,330 --> 00:25:51,160
in black I have the assignment
statements.

601
00:25:51,160 --> 00:25:53,260
That print is a keyword.

602
00:25:53,260 --> 00:25:56,980
It's a command to Python
to do something.

603
00:25:56,980 --> 00:26:00,690
As a consequence, I can't use
it as a variable name.

604
00:26:00,690 --> 00:26:01,780
All right, think about
it for a second.

605
00:26:01,780 --> 00:26:04,680
If I wanted to use print as a
variable name, how do I get

606
00:26:04,680 --> 00:26:08,980
the system to decide gee, do
I want print as a value for

607
00:26:08,980 --> 00:26:11,560
something, or do I want
print as a command?

608
00:26:11,560 --> 00:26:13,670
So there's a sequence of these
that are blocked out, and I--

609
00:26:13,670 --> 00:26:16,340
John, I think there are
what, twenty-eight?

610
00:26:16,340 --> 00:26:18,020
Something like that,
TAs, is that right?

611
00:26:18,020 --> 00:26:20,930
Twenty-eight keywords
that are blocked?

612
00:26:20,930 --> 00:26:23,240
We'll find them as
we go along--

613
00:26:23,240 --> 00:26:24,530
OK.

614
00:26:24,530 --> 00:26:26,710
Having done this now, I can
simply go ahead and run this,

615
00:26:26,710 --> 00:26:29,120
and in fact if I go up here to
run, you'll see I've got both

616
00:26:29,120 --> 00:26:31,800
an option to check the module,
though in this case I'm just

617
00:26:31,800 --> 00:26:33,790
going to run it.

618
00:26:33,790 --> 00:26:35,340
Oh, notice what happened.

619
00:26:35,340 --> 00:26:37,620
It ran through that sequence of
instructions, in particular

620
00:26:37,620 --> 00:26:41,450
it bound x to the value three,
and then it took x times x,

621
00:26:41,450 --> 00:26:43,800
got the value of x multipied by
x, which of course is nine,

622
00:26:43,800 --> 00:26:46,670
bound that to the value of x,
and then it printed out the

623
00:26:46,670 --> 00:26:49,610
value, and now it's sitting
here waiting for an input.

624
00:26:49,610 --> 00:26:52,180
You notice what it did, it
printed out that little, right

625
00:26:52,180 --> 00:26:53,980
up here I'd said enter a number
and that's what it's

626
00:26:53,980 --> 00:26:58,790
printed out, so I can enter a
number and it prints it out.

627
00:26:58,790 --> 00:27:00,450
Great.

628
00:27:00,450 --> 00:27:01,950
Let's run it again.

629
00:27:01,950 --> 00:27:04,370
Actually for that, I can just
use, if I'm lucky, function

630
00:27:04,370 --> 00:27:09,220
F5, which didn't work, so let me
try it again., here we go.

631
00:27:09,220 --> 00:27:11,550
We're going to run that module.

632
00:27:11,550 --> 00:27:14,690
OK.

633
00:27:14,690 --> 00:27:17,050
Whoa.

634
00:27:17,050 --> 00:27:20,030
What happened?

635
00:27:20,030 --> 00:27:20,810
I said enter a number.

636
00:27:20,810 --> 00:27:21,130
I didn't.

637
00:27:21,130 --> 00:27:21,970
I gave it a string.

638
00:27:21,970 --> 00:27:23,240
And it still took it.

639
00:27:23,240 --> 00:27:25,080
And printed it up.

640
00:27:25,080 --> 00:27:26,790
Well, this is one of the places
where I want to come

641
00:27:26,790 --> 00:27:29,840
back to that highlighting
of what do things do?

642
00:27:29,840 --> 00:27:33,370
Even though my statement said
enter a number, in particular,

643
00:27:33,370 --> 00:27:37,040
raw input here simply takes in a
set of characters and treats

644
00:27:37,040 --> 00:27:38,390
it as a string.

645
00:27:38,390 --> 00:27:39,930
And then prints it back out.

646
00:27:39,930 --> 00:27:42,220
So if in fact I wanted to make
sure this was a number, I

647
00:27:42,220 --> 00:27:44,460
should have done something like
either try and convert it

648
00:27:44,460 --> 00:27:47,330
to a number, which of course
failed here, or put in a check

649
00:27:47,330 --> 00:27:48,610
to say where it is.

650
00:27:48,610 --> 00:27:50,620
So it's a way of reminding you,
I've got to be careful

651
00:27:50,620 --> 00:27:53,530
about the types of things
that I put in.

652
00:27:53,530 --> 00:27:56,380
OK.

653
00:27:56,380 --> 00:28:01,100
This is still boring, so let's
step on the accelerator.

654
00:28:01,100 --> 00:28:04,710
What I have now is the
following: I can write

655
00:28:04,710 --> 00:28:07,660
expressions, do combinations of
things to get out values, I

656
00:28:07,660 --> 00:28:11,260
can store them away, I
can print them up.

657
00:28:11,260 --> 00:28:13,760
But literally all I can do at
this stage is write what we

658
00:28:13,760 --> 00:28:18,060
would call a straight-line
program, that is, a program in

659
00:28:18,060 --> 00:28:28,540
which we execute in which we
execute the sequence of

660
00:28:28,540 --> 00:28:31,300
instructions one by one.

661
00:28:31,300 --> 00:28:34,240
Simply walk down that
list. That's what we

662
00:28:34,240 --> 00:28:34,790
just did there, right?

663
00:28:34,790 --> 00:28:36,780
We just walked through that
list. This is boring.

664
00:28:36,780 --> 00:28:39,290
In fact, you can do some nice
things to prove what is the

665
00:28:39,290 --> 00:28:42,220
class of functions you can
compute with straight-line

666
00:28:42,220 --> 00:28:44,330
programs, and what you'd see if
you did that is, it's not

667
00:28:44,330 --> 00:28:46,730
particularly interesting.

668
00:28:46,730 --> 00:28:48,050
OK.

669
00:28:48,050 --> 00:28:49,890
Let's go back and think
about our recipes.

670
00:28:49,890 --> 00:28:52,010
What we use as our
motivation here.

671
00:28:52,010 --> 00:28:54,880
Even in real recipes, you
have things like,

672
00:28:54,880 --> 00:28:59,210
if needed, add sugar.

673
00:28:59,210 --> 00:29:00,320
That's a decision.

674
00:29:00,320 --> 00:29:01,520
That's a conditional.

675
00:29:01,520 --> 00:29:02,340
That's a branch.

676
00:29:02,340 --> 00:29:04,910
That says, if something
is true, do something.

677
00:29:04,910 --> 00:29:06,970
Otherwise, do something
different.

678
00:29:06,970 --> 00:29:09,510
So to really add to this, we
need to have branching

679
00:29:09,510 --> 00:29:19,370
programs. What I mean by that
is, a branching program is

680
00:29:19,370 --> 00:29:32,750
something that can change the
order of instructions based on

681
00:29:32,750 --> 00:29:46,620
some test. And that test is
usually a value of a variable.

682
00:29:46,620 --> 00:29:47,730
OK.

683
00:29:47,730 --> 00:29:49,910
And these get a whole lot
more interesting.

684
00:29:49,910 --> 00:29:52,260
So let's look at a little
example, and this is going to,

685
00:29:52,260 --> 00:29:54,590
excuse me, both allow us
introduce the syntax as well

686
00:29:54,590 --> 00:29:56,520
as what we want to have
as the flow of

687
00:29:56,520 --> 00:29:57,530
control inside of here.

688
00:29:57,530 --> 00:30:02,960
So let me go back up here, and
I'm going to comment out that

689
00:30:02,960 --> 00:30:10,250
region, and let's uncomment
this region.

690
00:30:10,250 --> 00:30:12,480
I want to write a little
piece of code.

691
00:30:12,480 --> 00:30:14,890
It's going to print out even or
odd, depending on whether

692
00:30:14,890 --> 00:30:19,100
the value I put in, which is x
in this case, is even or odd.

693
00:30:19,100 --> 00:30:20,860
Think about that.

694
00:30:20,860 --> 00:30:24,490
That says, if this thing has
some particular value, I want

695
00:30:24,490 --> 00:30:26,420
to do one thing; otherwise,
I want to

696
00:30:26,420 --> 00:30:28,010
do something different.

697
00:30:28,010 --> 00:30:29,970
And let's look at the
syntax of this.

698
00:30:29,970 --> 00:30:31,936
This is the first of the
conditionals that

699
00:30:31,936 --> 00:30:36,530
we're going to see.

700
00:30:36,530 --> 00:30:38,740
Notice the format.

701
00:30:38,740 --> 00:30:39,290
I'm going to go up there.

702
00:30:39,290 --> 00:30:41,360
The first statement right
here, that's just an

703
00:30:41,360 --> 00:30:43,100
assignment statement, I'm
giving some value to x.

704
00:30:43,100 --> 00:30:45,100
We could make it something
different.

705
00:30:45,100 --> 00:30:47,360
And then, notice the
structure here.

706
00:30:47,360 --> 00:30:48,310
The next three statements.

707
00:30:48,310 --> 00:30:50,900
First of all, IF is a keyword.
which makes sense.

708
00:30:50,900 --> 00:30:55,430
It is followed, as you can see
there, by some expression,

709
00:30:55,430 --> 00:30:56,360
followed by a colon.

710
00:30:56,360 --> 00:30:59,950
And in fact, that colon is
important, so let me stress

711
00:30:59,950 --> 00:31:00,680
this over here.

712
00:31:00,680 --> 00:31:11,930
The colon is important It's
defining the beginning of a

713
00:31:11,930 --> 00:31:12,970
block of instructions.

714
00:31:12,970 --> 00:31:13,380
Yes sir.

715
00:31:13,380 --> 00:31:17,200
STUDENT: [UNINTELLIGIBLE]

716
00:31:17,200 --> 00:31:19,150
PROFESSOR JIM ERICSON: Based on
a test. Usually the value

717
00:31:19,150 --> 00:31:21,490
of a variable.

718
00:31:21,490 --> 00:31:22,620
OK, so let me go back
to where I am.

719
00:31:22,620 --> 00:31:23,580
I'm looking at that
piece of code.

720
00:31:23,580 --> 00:31:27,260
What that colon is saying is,
I'm about to begin a sequence

721
00:31:27,260 --> 00:31:29,840
of instructions that I want
to treat as a block.

722
00:31:29,840 --> 00:31:38,940
So it identifies a block
of instructions.

723
00:31:38,940 --> 00:31:43,000
It's, and in particular, the
colon is the start, and the

724
00:31:43,000 --> 00:31:48,340
carriage return is the end.

725
00:31:48,340 --> 00:31:49,210
Now what in the world
does that mean?

726
00:31:49,210 --> 00:31:50,930
I'm doing a lot of words here,
let me try and say this a

727
00:31:50,930 --> 00:31:51,540
little bit better.

728
00:31:51,540 --> 00:31:54,290
That code says the following:
the IF says, I've got an

729
00:31:54,290 --> 00:31:56,540
expression, I'm going
to evaluate it.

730
00:31:56,540 --> 00:32:01,350
If that value is true, I want
to do a set of things.

731
00:32:01,350 --> 00:32:04,230
And that set of things is
identified by the sequence of

732
00:32:04,230 --> 00:32:09,020
commands that are indented in,
this one right here, following

733
00:32:09,020 --> 00:32:12,600
the colon but before I get
back to the same place in

734
00:32:12,600 --> 00:32:14,940
terms of the indentation.

735
00:32:14,940 --> 00:32:19,780
If that test is not true, I want
to skip this instruction,

736
00:32:19,780 --> 00:32:23,340
and there's a second keyword
else, followed by a colon, and

737
00:32:23,340 --> 00:32:24,880
that tells me the thing
I want to do in the

738
00:32:24,880 --> 00:32:26,880
case that it's false.

739
00:32:26,880 --> 00:32:36,020
So in fact if I run this,
ah, and save it, and

740
00:32:36,020 --> 00:32:37,680
it prints out odd.

741
00:32:37,680 --> 00:32:39,250
So, what happened here?

742
00:32:39,250 --> 00:32:41,250
Well, let's look at the code.

743
00:32:41,250 --> 00:32:43,410
Right? x is initially
bound to fifteen.

744
00:32:43,410 --> 00:32:44,250
I get to the IF.

745
00:32:44,250 --> 00:32:46,550
The IF says, evaluate that
next expression.

746
00:32:46,550 --> 00:32:49,270
In that next expression, I'm
actually taking advantage of

747
00:32:49,270 --> 00:32:51,380
the fact that I'm doing integer
multiplication and

748
00:32:51,380 --> 00:32:52,720
division here.

749
00:32:52,720 --> 00:32:55,100
Right, that divide is, if x is
an integer and two is an

750
00:32:55,100 --> 00:32:56,000
integer, what's it
going to do?

751
00:32:56,000 --> 00:32:59,670
If x was even, x divided by two
is going to be actually

752
00:32:59,670 --> 00:33:02,200
the half of x, right?

753
00:33:02,200 --> 00:33:04,740
If x is odd, that integer
division is going to give me

754
00:33:04,740 --> 00:33:08,340
the number of multiples of two,
that go into x, plus a

755
00:33:08,340 --> 00:33:11,580
remainder, which I'm going
to throw away.

756
00:33:11,580 --> 00:33:13,970
In either case, I take that
value and multiply back by

757
00:33:13,970 --> 00:33:17,930
two, if it was even I get back
the original number, if it was

758
00:33:17,930 --> 00:33:20,530
odd, I'm not going to get back
the original number, so I can

759
00:33:20,530 --> 00:33:22,940
just check to see if
they're the same.

760
00:33:22,940 --> 00:33:24,510
OK, so a little nuance
that I'm using there.

761
00:33:24,510 --> 00:33:26,560
So, the first thing that IF
does, bleah that IF says is,

762
00:33:26,560 --> 00:33:30,220
evaluate that expression and
if it's true, do the next

763
00:33:30,220 --> 00:33:31,820
thing, the thing after
the colon.

764
00:33:31,820 --> 00:33:34,290
In this case it's not true, so
it's going to skip down and

765
00:33:34,290 --> 00:33:38,110
evaluate the thing printed
up the odd.

766
00:33:38,110 --> 00:33:38,390
OK.

767
00:33:38,390 --> 00:33:38,900
What-- yes.

768
00:33:38,900 --> 00:33:41,850
STUDENT: [INAUDIBLE]

769
00:33:41,850 --> 00:33:42,895
PROFESSOR JIM ERICSON:
Thank you.

770
00:33:42,895 --> 00:33:44,510
I was hoping somebody would
ask that question.

771
00:33:44,510 --> 00:33:47,635
The question was, if you didn't
hear, why do I have two

772
00:33:47,635 --> 00:33:49,070
equal signs?

773
00:33:49,070 --> 00:33:51,380
It's like I'm doing
this, right?

774
00:33:51,380 --> 00:33:52,680
Anybody have a se--%uFFFD
why don't I just

775
00:33:52,680 --> 00:33:53,390
use an equal sign?

776
00:33:53,390 --> 00:33:54,790
I want to know if something's
equal to something.

777
00:33:54,790 --> 00:33:55,210
Yeah.

778
00:33:55,210 --> 00:33:55,814
STUDENT: [INAUDIBLE]

779
00:33:55,814 --> 00:33:58,875
PROFESSOR JIM ERICSON:
Absolutely.

780
00:33:58,875 --> 00:34:02,510
The equal sign is
going to bind--

781
00:34:02,510 --> 00:34:05,060
Nice catch.

782
00:34:05,060 --> 00:34:06,640
John, this is so much
fun, throwing candy.

783
00:34:06,640 --> 00:34:07,950
I've got to say, we've got
to do this more often--

784
00:34:07,950 --> 00:34:08,160
Right.

785
00:34:08,160 --> 00:34:09,420
Let me, let me get
to the point.

786
00:34:09,420 --> 00:34:10,520
What does an equal sign do?

787
00:34:10,520 --> 00:34:11,560
It is an assignment.

788
00:34:11,560 --> 00:34:14,790
It says, take this thing on the
left and use it as a name

789
00:34:14,790 --> 00:34:17,050
to bind to the value
on the right.

790
00:34:17,050 --> 00:34:17,950
It's not what I want here.

791
00:34:17,950 --> 00:34:20,720
Having already chosen to use
equal as an assignment, I need

792
00:34:20,720 --> 00:34:23,130
something else to
do comparison.

793
00:34:23,130 --> 00:34:24,570
And that's why I use
double equals.

794
00:34:24,570 --> 00:34:27,320
Those two equal signs are
saying, is this thing equal

795
00:34:27,320 --> 00:34:31,450
to, in value, the thing
on the other side?

796
00:34:31,450 --> 00:34:32,780
OK.

797
00:34:32,780 --> 00:34:36,050
Now, having done that, again I
want to stress this idea and

798
00:34:36,050 --> 00:34:38,520
I'm going to write it out one
more time, that there's a

799
00:34:38,520 --> 00:34:42,780
particular format here.

800
00:34:42,780 --> 00:34:47,080
So we have if, and that is
followed by, I'm going to use

801
00:34:47,080 --> 00:34:49,100
angle braces here just to
indicates something goes in

802
00:34:49,100 --> 00:34:54,080
here, some test followed
by a colon.

803
00:34:54,080 --> 00:35:02,470
That is followed by a block
of instructions.

804
00:35:02,470 --> 00:35:08,420
And we have an ELSE, followed by
a colon in some other block

805
00:35:08,420 --> 00:35:17,240
of instructions.

806
00:35:17,240 --> 00:35:20,240
And I want you to get used to
this, that colon is important,

807
00:35:20,240 --> 00:35:23,860
it identifies the start, and
then the set of indented

808
00:35:23,860 --> 00:35:26,740
things identify all the things
at the same level, and when we

809
00:35:26,740 --> 00:35:29,130
reset back to the previous
level, that's when we go back

810
00:35:29,130 --> 00:35:31,070
to where we were.

811
00:35:31,070 --> 00:35:32,900
OK.

812
00:35:32,900 --> 00:35:35,750
Now, that's a nice simple little
test, let's look at a

813
00:35:35,750 --> 00:35:37,460
couple of other examples
to get a sense of

814
00:35:37,460 --> 00:35:39,270
what this will do.

815
00:35:39,270 --> 00:35:48,130
OK, let me comment this out,
and let's look at this next

816
00:35:48,130 --> 00:35:50,260
little piece of code.

817
00:35:50,260 --> 00:35:51,470
All right.

818
00:35:51,470 --> 00:35:53,670
I'm binding a z to be some
value, and then I'm

819
00:35:53,670 --> 00:35:55,050
going to run this.

820
00:35:55,050 --> 00:36:02,040
Well, let's just run it
and see what it does.

821
00:36:02,040 --> 00:36:03,590
Nothing.

822
00:36:03,590 --> 00:36:04,240
OK, so why?

823
00:36:04,240 --> 00:36:05,010
Well, let's look at it.

824
00:36:05,010 --> 00:36:08,950
I'm doing a test there to say,
if the string x is less than

825
00:36:08,950 --> 00:36:12,680
the value of b, and x does not
appear before b as strings,

826
00:36:12,680 --> 00:36:16,550
then I was going to do, oh, a
couple of things, because

827
00:36:16,550 --> 00:36:18,930
they're at the same
block level.

828
00:36:18,930 --> 00:36:22,330
Given that that wasn't
true, it did nothing.

829
00:36:22,330 --> 00:36:25,010
Now, wait a minute, you say,
where's the ELSE clause?

830
00:36:25,010 --> 00:36:26,390
And the answer is,
I don't need one.

831
00:36:26,390 --> 00:36:29,820
All right, if this is purely a
test of, if this is true do

832
00:36:29,820 --> 00:36:32,590
this otherwise I don't care, I
don't need the ELSE clause in

833
00:36:32,590 --> 00:36:33,120
there to identify it.

834
00:36:33,120 --> 00:36:35,820
All right?

835
00:36:35,820 --> 00:36:39,100
Second thing I want to look at
is, suppose I compare that the

836
00:36:39,100 --> 00:36:39,760
one below it.

837
00:36:39,760 --> 00:36:45,720
Oops, that I don't want to do.

838
00:36:45,720 --> 00:36:53,840
Comment that out, and let's
uncomment this.

839
00:36:53,840 --> 00:36:56,310
Yeah, I've still got a binding
for z and I'm giving it the

840
00:36:56,310 --> 00:36:59,710
same test, but notice now I've
got the two same commands but

841
00:36:59,710 --> 00:37:01,830
they have different
indentation.

842
00:37:01,830 --> 00:37:08,790
In this case, in fact I do
get a different behavior.

843
00:37:08,790 --> 00:37:10,330
Why?

844
00:37:10,330 --> 00:37:14,100
Because that block identifies a
set of things that I'm going

845
00:37:14,100 --> 00:37:16,090
to do if the test is true.

846
00:37:16,090 --> 00:37:18,630
If the test was not true, notice
that that last command

847
00:37:18,630 --> 00:37:21,520
for print Mon is now back at the
same level as the IF, so

848
00:37:21,520 --> 00:37:25,190
what this says is the IF does
the test, having done the

849
00:37:25,190 --> 00:37:27,300
test, it decides I'm not going
to do anything in the block

850
00:37:27,300 --> 00:37:29,830
below it, I'm going to skip
down therefore to the next

851
00:37:29,830 --> 00:37:32,850
instruction at the same level
as the IF, which gets me to

852
00:37:32,850 --> 00:37:35,690
the second print statement.

853
00:37:35,690 --> 00:37:36,140
OK.

854
00:37:36,140 --> 00:37:38,830
So now we're seeing some of
these variations, let's see

855
00:37:38,830 --> 00:37:39,800
what else can we do here.

856
00:37:39,800 --> 00:37:41,550
So let me just to try something
a little more

857
00:37:41,550 --> 00:37:43,520
interesting, and then we'll
get to writing some simple

858
00:37:43,520 --> 00:37:47,000
programs. So I'm going to
comment those out, and let's

859
00:37:47,000 --> 00:37:53,820
go down to this piece of
code, and uncomment it.

860
00:37:53,820 --> 00:37:55,710
Ooh yes, that was brilliant.

861
00:37:55,710 --> 00:37:59,010
Let's try this again.

862
00:37:59,010 --> 00:38:04,980
And uncomment that, and
uncomment it again.

863
00:38:04,980 --> 00:38:06,870
Right, so here's a little piece
of code that's going to

864
00:38:06,870 --> 00:38:09,670
print out the smallest
value of three.

865
00:38:09,670 --> 00:38:12,140
And notice what this
is showing is that

866
00:38:12,140 --> 00:38:13,760
the IFs can be nested.

867
00:38:13,760 --> 00:38:15,390
All right, it's so if I looked
at it, it's going to say that

868
00:38:15,390 --> 00:38:18,860
IF x is y-- sorry, IF x is less
than y, THEN check to see

869
00:38:18,860 --> 00:38:22,930
IF x is less than z, and if
that's true, print out x is

870
00:38:22,930 --> 00:38:26,260
the smallest. And notice the
structure of it, if it's not

871
00:38:26,260 --> 00:38:28,380
true I'm going to go to that
next ELSE, and print out that

872
00:38:28,380 --> 00:38:31,330
z is smallest. If the first test
wasn't true, I'm going to

873
00:38:31,330 --> 00:38:33,680
skip that whole block and just
go down and print out that y

874
00:38:33,680 --> 00:38:37,190
was smallest. So notice the
nesting, I can flow my way

875
00:38:37,190 --> 00:38:40,240
through how those tests are
actually going to take place.

876
00:38:40,240 --> 00:38:46,570
All right, so let's run this
and see what happens.

877
00:38:46,570 --> 00:38:50,970
Great. y is smallest. OK.

878
00:38:50,970 --> 00:38:55,070
Is that code correct?

879
00:38:55,070 --> 00:38:56,680
Is that a tentative
hand back there?

880
00:38:56,680 --> 00:38:57,650
Yeah.

881
00:38:57,650 --> 00:39:00,900
STUDENT: Let me compare
y to [INAUDIBLE]

882
00:39:00,900 --> 00:39:02,320
PROFESSOR JIM ERICSON: Yeah,
it's not doing all of the

883
00:39:02,320 --> 00:39:03,440
comparisons.

884
00:39:03,440 --> 00:39:05,055
All right, and let's just check
this out, because I want

885
00:39:05,055 --> 00:39:08,220
to make a point of this, let's
go back and do the following.

886
00:39:08,220 --> 00:39:18,150
Let's take y, change it to
thirteen, let's run it, hmm.

887
00:39:18,150 --> 00:39:20,380
So what did I miss here?

888
00:39:20,380 --> 00:39:22,120
Two important points.

889
00:39:22,120 --> 00:39:24,770
First one, when I write a piece
of code, especially code

890
00:39:24,770 --> 00:39:28,600
that has branches in it, when
I design test cases for that

891
00:39:28,600 --> 00:39:32,310
piece of code, I should try and
have a specific test case

892
00:39:32,310 --> 00:39:35,940
for each possible path
through the code.

893
00:39:35,940 --> 00:39:38,640
And by just doing that, I just
spotted, there's a bug here.

894
00:39:38,640 --> 00:39:40,440
And the bug was in my thinking,
I did not look for

895
00:39:40,440 --> 00:39:41,110
all of the tests.

896
00:39:41,110 --> 00:39:49,680
So the way I can fix that, is,
let me comment that out, and

897
00:39:49,680 --> 00:40:03,610
keep doing that, comment that
out, let's uncomment this,

898
00:40:03,610 --> 00:40:04,880
notice the structure here.

899
00:40:04,880 --> 00:40:06,610
I now have multiple tests.

900
00:40:06,610 --> 00:40:08,340
So actually, let's just run
it and then we'll talk

901
00:40:08,340 --> 00:40:09,140
about what it does.

902
00:40:09,140 --> 00:40:16,320
I run this, yeah, I have a
syntax error, yes indeed,

903
00:40:16,320 --> 00:40:20,060
because I forgot to comment that
one out, all right, and

904
00:40:20,060 --> 00:40:27,640
cue, we'll try it again.

905
00:40:27,640 --> 00:40:29,200
Ah-ha!

906
00:40:29,200 --> 00:40:31,940
And let's quickly look at
the structure of this.

907
00:40:31,940 --> 00:40:34,740
This now has, gee, a funny
thing, it says IF x is less

908
00:40:34,740 --> 00:40:39,530
than y AND x is less than
z, then do something.

909
00:40:39,530 --> 00:40:42,300
And then it has a strange thing
called ELIF, which is

910
00:40:42,300 --> 00:40:46,210
simply short for else/if in a
second test. So the way to

911
00:40:46,210 --> 00:40:48,370
think about this in terms of
flow is, it starts with that

912
00:40:48,370 --> 00:40:51,470
if and it says, check both
of those things.

913
00:40:51,470 --> 00:40:54,000
And that fact that both of those
things is the fact that

914
00:40:54,000 --> 00:41:06,520
we're using Boolean
combination here.

915
00:41:06,520 --> 00:41:11,510
It is to say, we can take any
logical expressions, combine

916
00:41:11,510 --> 00:41:14,440
them together with AND, OR,
or NOT to make a complex

917
00:41:14,440 --> 00:41:17,830
expression, and use the value of
that expression as my test.

918
00:41:17,830 --> 00:41:19,755
And that's literally what I've
done there, right, I've got x

919
00:41:19,755 --> 00:41:22,000
less than y, that's a test, it
returns a Boolean, which by

920
00:41:22,000 --> 00:41:25,125
the way is the other type, at
least I would include here, it

921
00:41:25,125 --> 00:41:32,880
has only two values, which are
true and false, and what that

922
00:41:32,880 --> 00:41:37,870
code says, if x is less than y,
AND, logically, whatever I

923
00:41:37,870 --> 00:41:42,620
put up there, x is less than
z, then the combination is

924
00:41:42,620 --> 00:41:44,610
true, and therefore I'm
going to do something.

925
00:41:44,610 --> 00:41:47,850
So AND is if both arguments are
true it's true, OR is if

926
00:41:47,850 --> 00:41:50,330
either argument it's true it's
true, NOT is if the argument

927
00:41:50,330 --> 00:41:53,565
is not true it's true, and then
the last piece, as I said

928
00:41:53,565 --> 00:41:56,540
is, I can now have a sequence
of things I want to do.

929
00:41:56,540 --> 00:41:58,690
So if this is true do something
else, otherwise test

930
00:41:58,690 --> 00:42:00,960
and see if this is true, do
something else, as many as I

931
00:42:00,960 --> 00:42:02,200
like followed by the end.

932
00:42:02,200 --> 00:42:05,560
And ELSE, it says, here's
what I want to do.

933
00:42:05,560 --> 00:42:07,050
OK.

934
00:42:07,050 --> 00:42:09,080
Now.

935
00:42:09,080 --> 00:42:12,330
Having added this in, I have
branching instructions.

936
00:42:12,330 --> 00:42:15,260
I have simple branching
programs. These are still

937
00:42:15,260 --> 00:42:16,450
awfully simple.

938
00:42:16,450 --> 00:42:16,645
OK?

939
00:42:16,645 --> 00:42:20,530
And they're awfully simple
because, all I can do now, is

940
00:42:20,530 --> 00:42:24,440
decide whether to execute some
piece of code or another.

941
00:42:24,440 --> 00:42:26,430
Said a different way, in the
case of the straight-line

942
00:42:26,430 --> 00:42:29,360
programs, how long would it
take to run a program?

943
00:42:29,360 --> 00:42:31,760
Well, basically, however many
instructions I have, because

944
00:42:31,760 --> 00:42:33,690
I've got to do each
one in order.

945
00:42:33,690 --> 00:42:36,720
With simple branching, how long
is it going to take to

946
00:42:36,720 --> 00:42:38,430
run a piece of code?

947
00:42:38,430 --> 00:42:42,240
Well at most, I'm going to
execute each instruction once.

948
00:42:42,240 --> 00:42:42,350
All right?

949
00:42:42,350 --> 00:42:44,320
Because the IFs are saying, if
it's true do this, otherwise

950
00:42:44,320 --> 00:42:46,070
skip on it.

951
00:42:46,070 --> 00:42:48,820
Therefore, for simple branching
programs, the length

952
00:42:48,820 --> 00:42:52,250
of time, the complexity
the code, is what

953
00:42:52,250 --> 00:42:53,630
we would call constant.

954
00:42:53,630 --> 00:42:56,560
That is, it's at most the length
of the actual number of

955
00:42:56,560 --> 00:42:57,080
instructions.

956
00:42:57,080 --> 00:42:59,840
It doesn't depend
on the input.

957
00:42:59,840 --> 00:43:00,880
Real simple programs.

958
00:43:00,880 --> 00:43:02,130
Let's take another
simple example.

959
00:43:02,130 --> 00:43:03,980
Suppose I want to compute
the average age

960
00:43:03,980 --> 00:43:05,750
of all the MIT faculty.

961
00:43:05,750 --> 00:43:07,470
There's about a thousand
of us.

962
00:43:07,470 --> 00:43:10,570
However I do that, I know that
should inherently take more

963
00:43:10,570 --> 00:43:12,880
time than it takes to compute
the average age of all the

964
00:43:12,880 --> 00:43:14,180
EECS faculty.

965
00:43:14,180 --> 00:43:16,080
There's only 125 of us.

966
00:43:16,080 --> 00:43:19,200
And that should take more time
than what it takes to compute

967
00:43:19,200 --> 00:43:21,960
the average of John's and my
ages, instructors in 600,

968
00:43:21,960 --> 00:43:23,020
because there's only
two of us.

969
00:43:23,020 --> 00:43:27,730
All right, those pieces of
code inherently involved

970
00:43:27,730 --> 00:43:30,920
something that does depend on
the size of the input, or on

971
00:43:30,920 --> 00:43:32,470
the particular input.

972
00:43:32,470 --> 00:43:35,060
And that is a preface to an
idea of computational

973
00:43:35,060 --> 00:43:36,270
complexity we're going
to come back to.

974
00:43:36,270 --> 00:43:38,500
One of the things we want to
help you do is identify the

975
00:43:38,500 --> 00:43:41,170
different classes of algorithms,
what their costs

976
00:43:41,170 --> 00:43:43,930
are, and how you can map
problems into the most

977
00:43:43,930 --> 00:43:47,200
efficient class to do
the computation.

978
00:43:47,200 --> 00:43:47,670
OK.

979
00:43:47,670 --> 00:43:48,700
Now.

980
00:43:48,700 --> 00:43:52,450
Think for a second about
computing the average age of

981
00:43:52,450 --> 00:43:53,790
the faculty.

982
00:43:53,790 --> 00:43:55,400
You can already kind of
see what I want to do.

983
00:43:55,400 --> 00:43:57,960
I, somehow if, I want to walk
through some sequence of data

984
00:43:57,960 --> 00:44:01,190
structures, gathering up or
doing the same thing, adding

985
00:44:01,190 --> 00:44:03,420
ages in until I get a total
age and then divide by the

986
00:44:03,420 --> 00:44:04,960
number faculty.

987
00:44:04,960 --> 00:44:07,580
How do I write a piece
of code for that?

988
00:44:07,580 --> 00:44:09,230
Well, let's go back
up to our original

989
00:44:09,230 --> 00:44:10,370
starting point of recipes.

990
00:44:10,370 --> 00:44:13,120
And I'm sure you don't remember,
but one of the

991
00:44:13,120 --> 00:44:18,820
things I had in my recipe, is
beat egg whites until stiff.

992
00:44:18,820 --> 00:44:19,200
OK.

993
00:44:19,200 --> 00:44:21,410
That until is an
important word.

994
00:44:21,410 --> 00:44:24,560
It's actually defining a test.
Let me rephrase it into

995
00:44:24,560 --> 00:44:26,760
garbled English that'll lead
more naturally into what I

996
00:44:26,760 --> 00:44:27,300
want to do.

997
00:44:27,300 --> 00:44:31,950
While the egg whites are
not stiff, beat them.

998
00:44:31,950 --> 00:44:33,840
That is a different
kind of structure.

999
00:44:33,840 --> 00:44:36,860
It has a test in it, which is
that while, while something is

1000
00:44:36,860 --> 00:44:40,970
true, do something, but I
want to keep doing it.

1001
00:44:40,970 --> 00:44:45,020
And so for that, we need
to add one last thing.

1002
00:44:45,020 --> 00:44:49,350
Which is iteration.

1003
00:44:49,350 --> 00:44:50,840
Or loops.

1004
00:44:50,840 --> 00:44:52,460
We're going to see variations of
this, we're going to see a

1005
00:44:52,460 --> 00:44:54,370
variation of it called
recursion, a little later on,

1006
00:44:54,370 --> 00:44:56,070
but for now we're just going
to talk about how do we do

1007
00:44:56,070 --> 00:44:57,260
iterations.

1008
00:44:57,260 --> 00:45:00,370
And I want to show you an
example of this, to lead to

1009
00:45:00,370 --> 00:45:04,640
both the syntax, and
to the semantics.

1010
00:45:04,640 --> 00:45:15,190
And let me comment that out,
and let's go to this one.

1011
00:45:15,190 --> 00:45:15,480
All right.

1012
00:45:15,480 --> 00:45:17,890
What does this piece
of code say?

1013
00:45:17,890 --> 00:45:19,090
Not, what does it do, but
what does it say.

1014
00:45:19,090 --> 00:45:21,140
Well, the first three statements
are just assignment

1015
00:45:21,140 --> 00:45:21,370
statements.

1016
00:45:21,370 --> 00:45:25,130
I'm binding x, y, and iters
left to some values.

1017
00:45:25,130 --> 00:45:27,700
And then notice the structure, I
got a keyword WHILE, there's

1018
00:45:27,700 --> 00:45:32,170
that color identifying it, and
in parentheses I have a test.

1019
00:45:32,170 --> 00:45:34,870
I'm expecting the value that
test to be a Boolean.

1020
00:45:34,870 --> 00:45:36,370
Followed by a colon.

1021
00:45:36,370 --> 00:45:38,820
The colon's identifying
a block of code.

1022
00:45:38,820 --> 00:45:41,390
And what this is
saying is, gee.

1023
00:45:41,390 --> 00:45:43,900
Check to see if the variable
iters left has a value

1024
00:45:43,900 --> 00:45:45,070
greater than zero.

1025
00:45:45,070 --> 00:45:47,600
If it does, then execute
each of the

1026
00:45:47,600 --> 00:45:50,460
instructions in that block.

1027
00:45:50,460 --> 00:45:52,050
So I'm going to have an
assignment of y, I'm going to

1028
00:45:52,050 --> 00:45:53,890
have an assignment of iters
left, I've got a comment that

1029
00:45:53,890 --> 00:45:57,070
I had borrowed in order to do
some debugging, and then what

1030
00:45:57,070 --> 00:45:57,840
do I want it to do?

1031
00:45:57,840 --> 00:46:02,190
I want it to go back around to
the test. Once again, say, is

1032
00:46:02,190 --> 00:46:03,940
that test true?

1033
00:46:03,940 --> 00:46:07,490
If it is true, execute the
sequence of instructions.

1034
00:46:07,490 --> 00:46:10,040
So in fact we can block this
out and see what it does.

1035
00:46:10,040 --> 00:46:16,400
If I make a little chart here,
I've got x, y, and iters left.

1036
00:46:16,400 --> 00:46:19,600
x starts off as I think I set
it up as, here I can't even

1037
00:46:19,600 --> 00:46:24,800
read it, is x is three, y is
zero, iters left is three.

1038
00:46:24,800 --> 00:46:25,940
I can hand-simulate it.

1039
00:46:25,940 --> 00:46:28,070
It says, is the value of iters
left greater than zero?

1040
00:46:28,070 --> 00:46:28,510
Yes it is.

1041
00:46:28,510 --> 00:46:30,710
So, execute those two
instructions.

1042
00:46:30,710 --> 00:46:34,560
It says, take value of y and
value of x, add them together,

1043
00:46:34,560 --> 00:46:36,600
and create that as the
new value of y.

1044
00:46:36,600 --> 00:46:36,760
All right.

1045
00:46:36,760 --> 00:46:38,310
That's the assigned statement.

1046
00:46:38,310 --> 00:46:41,310
It says, take iters left,
subtract one from it, and bind

1047
00:46:41,310 --> 00:46:44,830
that as the new value
of iters left.

1048
00:46:44,830 --> 00:46:47,000
Having reached the end of the
block, go back up and check

1049
00:46:47,000 --> 00:46:49,570
the test. Is iters left
greater than zero?

1050
00:46:49,570 --> 00:46:50,550
Yes it is.

1051
00:46:50,550 --> 00:46:54,270
So, evaluate the same sequence
of instructions again. y plus

1052
00:46:54,270 --> 00:46:57,320
x is six, that's my new value
of y, two minus one is one,

1053
00:46:57,320 --> 00:47:00,300
that's my new value of iters
left, go back up.

1054
00:47:00,300 --> 00:47:01,990
Is iters left greater
than zero?

1055
00:47:01,990 --> 00:47:02,720
Yes it is.

1056
00:47:02,720 --> 00:47:07,150
So once more, thank God I didn't
take 47 as an example,

1057
00:47:07,150 --> 00:47:12,050
x plus y, subtract one from
iters left, go back up to the

1058
00:47:12,050 --> 00:47:14,560
test. Is iters left's value
greater than zero?

1059
00:47:14,560 --> 00:47:16,380
No, it is not.

1060
00:47:16,380 --> 00:47:20,190
Therefore, skip the rest of that
block of code and go to

1061
00:47:20,190 --> 00:47:24,620
the next instruction, which
is, ah, print out y.

1062
00:47:24,620 --> 00:47:29,270
In fact, if we test this,
son of a gun.

1063
00:47:29,270 --> 00:47:32,060
Got a simple square
procedure,.

1064
00:47:32,060 --> 00:47:34,860
Right, It's just squaring an
integer, is what it's doing.

1065
00:47:34,860 --> 00:47:36,150
But notice the structure.

1066
00:47:36,150 --> 00:47:39,080
Now I have the ability to create
a loop, that is, to

1067
00:47:39,080 --> 00:47:41,880
reuse the same pieces of
code over and over

1068
00:47:41,880 --> 00:47:43,870
again as I go around.

1069
00:47:43,870 --> 00:47:47,030
And this adds, now, a lot
of power to the kinds

1070
00:47:47,030 --> 00:47:49,040
of code I can write.

1071
00:47:49,040 --> 00:47:51,610
Notice some other things I want
to highlight on this.

1072
00:47:51,610 --> 00:47:52,610
All right?

1073
00:47:52,610 --> 00:47:57,240
The first one is, that test
has to involve-- shouldn't

1074
00:47:57,240 --> 00:47:59,300
have to, but almost always is
going to involve-- the value

1075
00:47:59,300 --> 00:48:01,470
of some variable.

1076
00:48:01,470 --> 00:48:05,340
What if I don't change the value
of that variable inside

1077
00:48:05,340 --> 00:48:05,960
of the code?

1078
00:48:05,960 --> 00:48:11,730
Or, another way of saying it
is, what if I did this?

1079
00:48:11,730 --> 00:48:13,950
Comment it up.

1080
00:48:13,950 --> 00:48:15,170
What happens if I
run this sucker?

1081
00:48:15,170 --> 00:48:17,650
STUDENT: [INAUDIBLE]

1082
00:48:17,650 --> 00:48:19,210
PROFESSOR JIM ERICSON: Yeah.

1083
00:48:19,210 --> 00:48:20,230
It'll go forever.

1084
00:48:20,230 --> 00:48:21,590
Absolutely, right?

1085
00:48:21,590 --> 00:48:23,390
It's going to loop into
an infinite loop--

1086
00:48:23,390 --> 00:48:26,690
I think I can hit this close,
ah, no I can't, boy what a

1087
00:48:26,690 --> 00:48:27,940
terrible aim--

1088
00:48:27,940 --> 00:48:30,120
All right, what has
[UNINTELLIGIBLE PHRASE] try

1089
00:48:30,120 --> 00:48:32,200
again, the point I'm trying to
make here-- thank God we're at

1090
00:48:32,200 --> 00:48:34,330
the end of this lecture, my
tongue is falling apart-- the

1091
00:48:34,330 --> 00:48:37,940
point I'm trying to make is,
that test needs to involve

1092
00:48:37,940 --> 00:48:40,870
some loop variable
that is changing.

1093
00:48:40,870 --> 00:48:42,575
Otherwise the test is always
going to be true, we're going

1094
00:48:42,575 --> 00:48:45,320
to go off here, but this would
loop forever if I did that.

1095
00:48:45,320 --> 00:48:45,710
All right.

1096
00:48:45,710 --> 00:48:49,100
Second question: or maybe a
better way of saying this, and

1097
00:48:49,100 --> 00:48:51,980
the general format you're likely
to see here is, a test

1098
00:48:51,980 --> 00:48:54,770
involving a variable name,
which must be initialized

1099
00:48:54,770 --> 00:48:57,910
outside of the loop, and which
interior to the loop gets

1100
00:48:57,910 --> 00:49:00,870
changed, so that the test
is going to change.

1101
00:49:00,870 --> 00:49:02,750
Here's the second question.

1102
00:49:02,750 --> 00:49:05,280
What value of inputs, what
values of x will this run

1103
00:49:05,280 --> 00:49:08,530
correctly for?

1104
00:49:08,530 --> 00:49:10,770
Probably should be
integers, right?

1105
00:49:10,770 --> 00:49:13,130
Otherwise, this is going to be
doing something strange, but

1106
00:49:13,130 --> 00:49:16,340
all integers?

1107
00:49:16,340 --> 00:49:18,350
All right, suppose I do this.

1108
00:49:18,350 --> 00:49:24,320
It's my last example.

1109
00:49:24,320 --> 00:49:26,730
Yeah, how about that, right?

1110
00:49:26,730 --> 00:49:29,450
We knew this was trying to do
squaring, so intellectually we

1111
00:49:29,450 --> 00:49:31,840
know we can square -4, it
ought to be 16, but what

1112
00:49:31,840 --> 00:49:33,630
happens here?

1113
00:49:33,630 --> 00:49:34,940
Double fudge knuckle.

1114
00:49:34,940 --> 00:49:35,960
All right?

1115
00:49:35,960 --> 00:49:39,000
It's going to run through the
loop, accumulating the

1116
00:49:39,000 --> 00:49:41,385
answers, but because I'm
subtracting, it's just going

1117
00:49:41,385 --> 00:49:44,690
to keep making x more and more
negative as it goes along,

1118
00:49:44,690 --> 00:49:46,680
again it's off into
an infinite loop.

1119
00:49:46,680 --> 00:49:49,360
Which is a way of reminding you
that I need to think as I

1120
00:49:49,360 --> 00:49:52,232
write the code about what are
my expectations from the

1121
00:49:52,232 --> 00:49:54,160
input, and how might
I enforce them.

1122
00:49:54,160 --> 00:49:56,050
In this case, I probably want
to make sure I use absolute

1123
00:49:56,050 --> 00:49:57,350
value of x before
I carry it on.

1124
00:49:57,350 --> 00:50:03,450
Yes ma'am.

1125
00:50:03,450 --> 00:50:11,130
STUDENT: [UNINTELLIGIBLE]

1126
00:50:11,130 --> 00:50:13,840
PROFESSOR JIM ERICSON: You're
absolutely right, because I

1127
00:50:13,840 --> 00:50:16,440
bind iters left to, um, yeah.

1128
00:50:16,440 --> 00:50:16,650
Yes.

1129
00:50:16,650 --> 00:50:16,980
Thank you.

1130
00:50:16,980 --> 00:50:19,260
Boy, two candy for you.

1131
00:50:19,260 --> 00:50:20,390
You caught me making an error.

1132
00:50:20,390 --> 00:50:21,040
Yes.

1133
00:50:21,040 --> 00:50:24,230
The point is, it's not going to
work, and she caught both

1134
00:50:24,230 --> 00:50:26,090
of them, impressive, it's not
going to work because iters

1135
00:50:26,090 --> 00:50:27,980
left is already negative, it's
just going to skip the whole

1136
00:50:27,980 --> 00:50:31,120
loop, and I'm in trouble, so
thank you for catching that.

1137
00:50:31,120 --> 00:50:31,370
All right.

1138
00:50:31,370 --> 00:50:33,380
I was going to do one more
example, but I've run you up

1139
00:50:33,380 --> 00:50:34,160
to the end of the time.

1140
00:50:34,160 --> 00:50:36,290
I'll leave the example on the
handout, it shows you another

1141
00:50:36,290 --> 00:50:38,150
version that we'll come
back to next time.

1142
00:50:38,150 --> 00:50:41,880
The key thing to notice is, I
now have the ability to create

1143
00:50:41,880 --> 00:50:44,130
iterations, which extends
well I can do.

1144
00:50:44,130 --> 00:50:46,840
And we'll see you next time.

1145
00:50:46,840 --> 00:50:48,872